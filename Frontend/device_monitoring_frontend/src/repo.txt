This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-12-22 14:45:47

# File Summary

## Purpose:

This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format:

The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
   a. A header with the file path (## File: path/to/file)
   b. The full contents of the file in a code block

## Usage Guidelines:

- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes:

- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

## Additional Information:

For more information about Repomix, visit: https://github.com/andersonby/python-repomix


# Repository Structure

```
components
  chakrauicomponents
    PopOver.tsx
    SwitchComponent.tsx
  customcomponents
    Accordion.tsx
    AlarmPanel
      AlarmCard.tsx
      AlarmPanel.tsx
      AlarmPanelContent.tsx
      CustomModal.tsx
      SelectDevicesComboBox.tsx
    Badge.tsx
    FileUploader.tsx
    Pagination.tsx
    Propertypanel
      AccordionVisibilityContext.tsx
      KeyValueField.tsx
      PropertyPanelContent.tsx
      PropertyPannel.tsx
      TabList.tsx
    ReactDiagramWrapper.tsx
    Settings.tsx
    SideBar.tsx
    Table
      TableComponent.tsx
      TableRow.tsx
  ui
    color-mode.tsx
    provider.tsx
    tooltip.tsx
models
  allInterfaces.ts
  propertyPanelInterfaces.ts
pages
  index.tsx
  _app.tsx
  _document.tsx
services
  alarmservice.ts
  deviceservice.ts
  graphqlClient.ts
sockets
  signalRConnection.ts
styles
  globals.css
  Home.module.css
  scss
    Accordion.module.scss
    AlarmPanel.module.scss
    Badge.module.scss
    FileUploader.module.scss
    global.scss
    Home.module.scss
    Pagination.module.scss
    PropertyPanel.module.scss
    Sidebar.module.scss
    Table.module.scss
    utilities.scss
utils
  customhooks
    useDeviceAlertSocket.ts
    useDeviceDetailSocket.ts
    useDevicesTopDataSocket.ts
  deepDiff.ts
  helperfunctions.ts
  helpervariables.ts
  propertypanelfunctions.tsx
__tests__
  components
    Accordion.test.tsx
    AlarmPanel
      AlarmPanelContent.test.tsx
      CustomModal.test.tsx
      SelectDevicesComboBox.test.tsx
    Badge.test.tsx
    ChakraUiComponents
      PopOver.test.tsx
      Swithc.test.tsx
    Pagination.test.tsx
    PropertyPanel
      AccordionVisibilityContext.test.tsx
      KeyValueField.test.tsx
      PropertyPanel.test.tsx
      PropertyPanelContent.test.tsx
      TabList.test.tsx
    Sidebar.test.tsx
    Table
      TableComponent.test.tsx
      TableRow.test.tsx
  hooks
    useDeviceTopDataSocket.test.ts
  Pages
    app.test.tsx
    document.test.tsx
  signalRConnection.test.ts
```

# Repository Files


## components/chakrauicomponents/PopOver.tsx

```text
import { Button, Popover, Portal } from "@chakra-ui/react"
import { useEffect, useState } from "react";

const PopOver = ({ children, isOpen , triggerContent }: any) => {
    const [isPopOverOpen, setIsPopOverOpen] = useState(isOpen);

    useEffect(() => {
        setIsPopOverOpen(isOpen);
    },[isOpen]);

    return (
        <Popover.Root open={isOpen} positioning={{ placement: "bottom-end" }}>
            <Popover.Trigger asChild>
                {triggerContent ? triggerContent : <Button variant="outline">Open PopOver</Button>}
            </Popover.Trigger>
            <Portal>
                <Popover.Positioner>
                    <Popover.Content bgColor={"#fff"} >
                        <Popover.Body onMouseEnter={() => setIsPopOverOpen(true)} onMouseLeave={() => {setIsPopOverOpen(false)}}>
                            {children}
                        </Popover.Body>
                    </Popover.Content>
                </Popover.Positioner>
            </Portal>
        </Popover.Root>
    )
}

export default PopOver;
```

## components/chakrauicomponents/SwitchComponent.tsx

```text
import { Switch } from "@chakra-ui/react"
import { HiCheck, HiX } from "react-icons/hi"
import { Tooltip } from "../ui/tooltip"

interface SwitchComponentProps {
  enabled: boolean
  tooltip?: string
  toggle: () => void
}

const SwitchComponent = (props: SwitchComponentProps) => {

  function returnSwitch() {
    return (
      <Switch.Root checked={props.enabled} colorPalette={"green"} size="md">
        <Switch.HiddenInput />
        <Switch.Control onClick={props.toggle}>
          <Switch.Thumb>
            <Switch.ThumbIndicator fallback={<HiX color="black" />}>
              <HiCheck />
            </Switch.ThumbIndicator>
          </Switch.Thumb>
        </Switch.Control>
      </Switch.Root>
    )
  }

  function renderSwitchContent() {
    if (props.tooltip && props.tooltip.length > 0) {
      return (
        <Tooltip openDelay={100} closeDelay={150} content={<span className="p-2">{props.tooltip}</span>}>
          <div>
            {returnSwitch()}
          </div>
        </Tooltip>
      )
    }
    else {
      return returnSwitch();
    }
  }


  return (
    renderSwitchContent()
  )
}

export default SwitchComponent;
```

## components/customcomponents/Accordion.tsx

```text
import { ReactNode, useEffect, useState } from 'react';
import styles from "@/styles/scss/Accordion.module.scss";
import { ChevronDown, ChevronUp } from 'lucide-react';
import { useAccordionState } from './Propertypanel/AccordionVisibilityContext';

type AccordionProps = {
  title: any;
  children: ReactNode;
  defaultOpen?: boolean;
  bgColor?: string;
  isTabList?:boolean;
  keyPath? : any;
};

export default function Accordion({
  title,
  children,
  defaultOpen = true,
  isTabList = false,
  bgColor = "#fff",
  keyPath,
}: AccordionProps) {
  const context = useAccordionState();

  const [localOpen, setLocalOpen] = useState(defaultOpen);

  const isContextControlled = !!keyPath;
  const isOpen = isContextControlled
    ? context?.getState(keyPath) ?? defaultOpen
    : localOpen;

  const toggleOpen = () => {
    if (isContextControlled) {
      context?.toggle(keyPath!, !isOpen);
    } else {
      setLocalOpen((prev) => !prev);
    }
  };

  useEffect(() => {
    if (isContextControlled) {
      context?.register(keyPath!, defaultOpen);
    }
  }, [keyPath]);

  return (
    <div className={styles.accordion} style={{ backgroundColor: bgColor }}>
      <div
        className={`${styles.header} ${isTabList ? styles.tabListHeader : ""}`}
        onClick={toggleOpen}
      >
        <div>{title}</div>
        <span>{isOpen ? <ChevronUp /> : <ChevronDown />}</span>
      </div>
      <div className={`${styles.content} ${isOpen ? styles.open : ""}`}>
        {children}
      </div>
    </div>
  );
}
```

## components/customcomponents/AlarmPanel/AlarmCard.tsx

```text
import { useEffect, useRef, useState } from "react";
import { ShieldCheck, ShieldEllipsis, ShieldX } from "lucide-react";
import styles from "@/styles/scss/AlarmPanel.module.scss";
import CustomModal from "./CustomModal";
import { formatRelativeTime } from "@/utils/helperfunctions";
import Badge from "../Badge";
import { Tooltip } from "@/components/ui/tooltip";

const severityColors: Record<string, { bg: string; color: string }> = {
    Critical: { bg: 'criticalAlarm', color: 'light' },
    Warning: { bg: 'warningAlarm', color: 'dark' },
    Information: { bg: 'infoAlarm', color: 'light' },
};

const AlarmCard = ({ removeacknowledgedAlarm, removeunacknowledgedAlarm, alarm, investigateAlarm, resolveAlarm, currentExpandedAckAlarm, setCurrentExpandedAckAlarm, currentExpandedUnackAlarm, setCurrentExpandedUnackAlarm, resolveInvestigatedAlarmData }: any) => {
    const [isExpanded, setIsExpanded] = useState(false);
    const [isResolveCommentModalOpen, setIsResolveCommentModalOpen] = useState(false);
    const [modalActionFunction, setModalActionFunction] = useState<any>(null);

    useEffect(() => {
        if(alarm.isAcknowledged){
            if (currentExpandedAckAlarm != "") {
                if (currentExpandedAckAlarm == alarm.id) {
                    setIsExpanded(true);
                    setIsResolveCommentModalOpen(false);
                }
                else {
                    setIsExpanded(false);
                    setIsResolveCommentModalOpen(false);
                }
            }
            else {
                setIsExpanded(false);
                setIsResolveCommentModalOpen(false);
            }
        }
        else if (currentExpandedUnackAlarm != "") {
            if (currentExpandedUnackAlarm == alarm.id) {
                setIsExpanded(true);
                setIsResolveCommentModalOpen(false);
            }
            else {
                setIsExpanded(false);
                setIsResolveCommentModalOpen(false);
            }
        }
        else {
            setIsExpanded(false);
            setIsResolveCommentModalOpen(false);
        }

    }, [currentExpandedAckAlarm, currentExpandedUnackAlarm]);

    const expandOrCollapseAlarm = () => {
        if (alarm.isAcknowledged) {
           currentExpandedAckAlarm == alarm.id ? setCurrentExpandedAckAlarm("") : setCurrentExpandedAckAlarm(alarm.id);
        }
        else {
            currentExpandedUnackAlarm == alarm.id ? setCurrentExpandedUnackAlarm("") : setCurrentExpandedUnackAlarm(alarm.id);
        }
    }

    const resolveInvestigatedAlarm = (alarmComment : string) => {
        resolveInvestigatedAlarmData(alarm.id, alarmComment)
    }

    const resolveUnacknowledgedAlarm = (alarmComment : string) => {
        resolveAlarm(alarm.id, alarmComment)
    }
    
    const ignoreInvestigatedAlarm = (alarmComment : string) => {
        removeacknowledgedAlarm(alarm.id, alarmComment);
    }

    const ignoreUnacknowledgedAlarm = (alarmComment : string) => {
        removeunacknowledgedAlarm(alarm.id, alarmComment);
    }


    return (
        <div className={`${styles.alarmCardContainer} ${isExpanded ? styles.expanded : ''} ${alarm.isAcknowledged && (alarm.alarmState == "Resolved" ? styles.resolvedAlarmCard : '')}`} onClick={() => { expandOrCollapseAlarm() }} >
            <CustomModal
                title={"Add comment"}
                isOpen={isResolveCommentModalOpen}
                actionFunction={modalActionFunction}
                setIsOpen={setIsResolveCommentModalOpen}
            />

            {alarm.isAcknowledged && (
                alarm.alarmState == "Investigating" ?
                    <Tooltip openDelay={100} closeDelay={150} content={<span className="p-2">{alarm.alarmComment}</span>}>
                        <ShieldEllipsis size={15} className={`${styles.ackAlarmStateIcon} ${styles.ackAlarmStateInvestigateIcon}`} />
                    </Tooltip>
                    :
                    alarm.alarmState == "Resolved" ?
                        <Tooltip openDelay={100} closeDelay={150} content={<span className="p-2">{alarm.alarmComment}</span>}>
                            <ShieldCheck size={15} className={`${styles.ackAlarmStateIcon} ${styles.ackAlarmStateResolveIcon}`} />
                        </Tooltip>
                        :
                        <Tooltip openDelay={100} closeDelay={150} content={<span className="p-2">{alarm.alarmComment}</span>}>
                            <ShieldX size={15} className={`${styles.ackAlarmStateIcon} ${styles.ackAlarmStateIgnoreIcon}`} />
                        </Tooltip>

            )}

            <div className={styles.alarmCardDiv}>
                <div>
                    <p className={styles.message}>{alarm.message}</p>
                    <span className={styles.time}>{formatRelativeTime(alarm.raisedAt)}</span>
                    {(alarm.isAcknowledged && (alarm.alarmState == "Resolved" || alarm.alarmState == "Ignored")) && <span className={styles.alarmComment}>{alarm.acknowledgedFrom}</span>}
                </div>
                <div className={styles.rightSide}>
                    <Badge
                        label={alarm.severity}
                        bgColor={severityColors[alarm.severity].bg}
                        textColor={severityColors[alarm.severity].color}
                    />
                </div>
            </div>

            {!alarm.isAcknowledged &&
                <div className={`${styles.expandedContent} ${isExpanded ? styles.show : ""}`}>
                    <Tooltip openDelay={100} closeDelay={150} content={<span>Mark as Investigating</span>}>
                    <button onClick={(event) => {
                            event.stopPropagation();
                            investigateAlarm(alarm.id);
                        }}
                        className={styles.ackBtn}
                    >
                        Investigate
                    </button>
                    </Tooltip>

                    <Tooltip openDelay={100} closeDelay={150} content={<span>Mark as Resolved</span>}>
                    <button
                        onClick={(event) => { event.stopPropagation(); setModalActionFunction(() => resolveUnacknowledgedAlarm); setIsResolveCommentModalOpen(true); }}
                        className={`${styles.ackBtn}`}
                    >
                        Resolve
                        {/* <Tooltip openDelay={100} closeDelay={150} content={<span>Add comment</span>}>
                            <FilePenLine
                                size={20}
                                onClick={(e) => {
                                    e.stopPropagation();
                                    setModalActionFunction(() => resolveUnacknowledgedAlarm);
                                    setIsResolveCommentModalOpen(true);
                                }}
                                className={styles.resolveCommentIcon}
                            />
                        </Tooltip> */}
                    </button>
                    </Tooltip>

                    <Tooltip openDelay={100} closeDelay={150} content={<span>Ignore Alarm</span>}>
                    <button
                        onClick={(event) => {event.stopPropagation(); setModalActionFunction(() => ignoreUnacknowledgedAlarm); setIsResolveCommentModalOpen(true);}}
                        className={`${styles.ackBtn}`}
                    >
                        Ignore
                        {/* <Tooltip openDelay={100} closeDelay={150} content={<span>Add comment</span>}>
                            <FilePenLine
                                size={20}
                                onClick={(e) => {
                                    e.stopPropagation();
                                    setModalActionFunction(() => ignoreUnacknowledgedAlarm);
                                    setIsResolveCommentModalOpen(true);
                                }}
                                className={styles.resolveCommentIcon}
                            />
                        </Tooltip> */}
                    </button>
                    </Tooltip>
                </div>}

            {(alarm.isAcknowledged && alarm.alarmState == "Investigating") &&
                <div className={`${styles.expandedContent} ${isExpanded ? styles.show : ""}`}>
                    <Tooltip openDelay={100} closeDelay={150} content={<span>Mark as Resolved</span>}>
                    <button
                        onClick={(event) => { event.stopPropagation(); setModalActionFunction(() => resolveInvestigatedAlarm); setIsResolveCommentModalOpen(true); }}
                        className={`${styles.ackBtn}`}>
                        Resolve
                        {/* <Tooltip openDelay={100} closeDelay={150} content={<span>Add comment</span>}>
                            <FilePenLine
                                size={20}
                                onClick={(e) => {
                                    e.stopPropagation();
                                    setModalActionFunction(() => resolveInvestigatedAlarm);
                                    setIsResolveCommentModalOpen(true);
                                }}
                                className={styles.resolveCommentIcon}
                            />
                        </Tooltip> */}
                    </button>
                    </Tooltip>

                    <Tooltip openDelay={100} closeDelay={150} content={<span>Ignore Alarm</span>}>
                    <button
                        onClick={(event) => { event.stopPropagation(); setModalActionFunction(() => ignoreInvestigatedAlarm); setIsResolveCommentModalOpen(true);}}
                        className={`${styles.ackBtn}`}
                    >
                        Ignore
                        {/* <Tooltip openDelay={100} closeDelay={150} content={<span>Add comment (Mandatory)</span>}>
                            <FilePenLine
                                size={20}
                                onClick={(e) => {
                                    e.stopPropagation();
                                    setModalActionFunction(() => ignoreInvestigatedAlarm);
                                    setIsResolveCommentModalOpen(true);
                                }}
                                className={styles.resolveCommentIcon}
                            />
                        </Tooltip> */}
                    </button>
                    </Tooltip>
                </div>}
        </div>
    );
};

export default AlarmCard;
```

## components/customcomponents/AlarmPanel/AlarmPanel.tsx

```text
// components/AlarmPanel.tsx
import React, { useCallback, useEffect, useRef, useState } from 'react';
import styles from "@/styles/scss/AlarmPanel.module.scss";
import Badge from '../Badge';
import Accordion from '../Accordion';
import { getAlarmPanelData, ignoreAlarm, investigateAlarm, resolveAlarm } from '@/services/alarmservice';
import { useDeviceAlertSocket } from '@/utils/customhooks/useDeviceAlertSocket';
import SelectDevicesComboBox from '@/components/customcomponents/AlarmPanel/SelectDevicesComboBox';
import { DateRangePicker } from 'rsuite';
import { Badge as ChakraBadge, CloseButton, Wrap } from "@chakra-ui/react";
import AlarmCard from './AlarmCard';
import { Tooltip } from '@/components/ui/tooltip';
import { ListX } from 'lucide-react';

const priorityMap: any = {
  Critical: 0,
  Warning: 1,
  Information: 2,
};

const AlarmPanel = ({ devicesNameMacList, selectedDevicePropertyPanel, setSelectedDevicePropertyPanel }: any) => {
  const [unacknowledgedAlarms, setUnacknowledgedAlarms] = useState<any[]>([]);
  const [acknowledgedAlarms, setAcknowledgedAlarms] = useState<any[]>([]);
  const [devices, setDevices] = useState<any[]>([]);
  const [dateRange, setDateRange] = useState<[Date, Date] | null>(null);
  const [selectedDevices, setSelectedDevices] = useState<string[]>([]);
  const [shouldConnectSignalR, setShouldConnectSignalR] = useState<boolean>(true);
  const [currentExpandedUnackAlarm, setCurrentExpandedUnackAlarm] = useState<string>("");
  const [currentExpandedAckAlarm, setCurrentExpandedAckAlarm] = useState<string>("");

  const handleAlertUpdates = useCallback((msg: string) => {
    const incomingUpdates = JSON.parse(msg);
    if (incomingUpdates) {
      filterAndSortAlarms(incomingUpdates);
    }
  }, []);

  // SignalR connection for alarm panel data  
  useDeviceAlertSocket("sampleDeviceId", handleAlertUpdates, "ReceiveAlarmPanelUpdates", shouldConnectSignalR);

  const severityColors: Record<string, { bg: string; color: string }> = {
    Critical: { bg: 'criticalAlarm', color: 'light' },
    Warning: { bg: 'warningAlarm', color: 'dark' },
    Information: { bg: 'infoAlarm', color: 'light' },
  };

  const fetchData = async (selectedDevices: any[], dateRange: any) => {
    const response = await getAlarmPanelData({ "devices": selectedDevices || [], "filterDateRange": dateRange || [] });
    if (!response)
      console.log("Network response was not ok");

    if (response && response.data) {
      filterAndSortAlarms(response.data);
    }
  };

  useEffect(() => {
    if (devicesNameMacList)
      setDevices(devicesNameMacList)
  }, []);

  useEffect(() => {
    if (!selectedDevicePropertyPanel) {
      fetchData(selectedDevices.map((s: any) => s.deviceMacId), dateRange);
      (selectedDevices.length == 0 && dateRange == null) ? setShouldConnectSignalR(true) : setShouldConnectSignalR(false);
    }
  }, [selectedDevices, dateRange]);

  useEffect(() => {
    if (selectedDevicePropertyPanel) {
      setSelectedDevices([selectedDevicePropertyPanel]);
      setSelectedDevicePropertyPanel(null);
    }
  }, [selectedDevicePropertyPanel]);

  function filterAndSortAlarms(data: any) {
    const investigatingAlarms = sortAlarmsDataBySeverity(data.filter((alarm: any) => alarm.isAcknowledged && alarm.alarmState == "Investigating"));
    const resolvedAlarms = sortAlarmsDataBySeverity(data.filter((alarm: any) => alarm.isAcknowledged && alarm.alarmState == "Resolved"));
    const ignoredAlarms = sortAlarmsDataBySeverity(data.filter((alarm: any) => alarm.isAcknowledged && alarm.alarmState == "Ignored"));
    setAcknowledgedAlarms([...investigatingAlarms, ...resolvedAlarms, ...ignoredAlarms]);
    setUnacknowledgedAlarms(sortAlarmsDataBySeverity(data.filter((alarm: any) => !alarm.isAcknowledged)));
  }

  function sortAlarmsDataBySeverity(alarms: any) {
    return alarms.sort((a: any, b: any) => {
      const severityDiff = priorityMap[a.severity] - priorityMap[b.severity];
      if (severityDiff !== 0) return severityDiff;

      // If same severity, sort by date (newest first)
      return new Date(b.raisedAt).getTime() - new Date(a.raisedAt).getTime();
    });
  }

  const investigateAlarmData = async (alarmId: any) => {
    const response = await investigateAlarm(alarmId);
    if (!response)
      console.log("Network response was not ok");

    if (response && response.data) {
      const ackAlarm = unacknowledgedAlarms.find((a: any) => a.id == alarmId);
      ackAlarm.alarmState = "Investigating";
      ackAlarm.isAcknowledged = true;
      ackAlarm.alarmComment = response.data.alarmComment;
      setUnacknowledgedAlarms((prev: any) => prev.filter((a: any) => a.id != alarmId));
      const ackAlarms = [ackAlarm, ...acknowledgedAlarms];
      const investigatingAlarms = sortAlarmsDataBySeverity(ackAlarms.filter((alarm: any) => alarm.isAcknowledged && alarm.alarmState == "Investigating"));
      const resolvedAlarms = sortAlarmsDataBySeverity(ackAlarms.filter((alarm: any) => alarm.isAcknowledged && alarm.alarmState == "Resolved"));
      const ignoredAlarms = sortAlarmsDataBySeverity(ackAlarms.filter((alarm: any) => alarm.isAcknowledged && alarm.alarmState == "Ignored"));
      setAcknowledgedAlarms([...investigatingAlarms, ...resolvedAlarms, ...ignoredAlarms]);
    }
  }

  const resolveAlarmData = async (alarmId: any, input: any) => {
    const response = await resolveAlarm(alarmId, input);
    if (!response)
      console.log("Network response was not ok");

    if (response && response.data) {
      const ackAlarm = unacknowledgedAlarms.find((a: any) => a.id == alarmId);
      ackAlarm.alarmState = response.data.alarmState;
      ackAlarm.isAcknowledged = response.data.isAcknowledged;
      ackAlarm.alarmComment = response.data.alarmComment;
      ackAlarm.acknowledgedFrom = response.data.acknowledgedFrom;
      setUnacknowledgedAlarms((prev: any) => prev.filter((a: any) => a.id != alarmId));
      const ackAlarms = [ackAlarm, ...acknowledgedAlarms];
      const investigatingAlarms = sortAlarmsDataBySeverity(ackAlarms.filter((alarm: any) => alarm.isAcknowledged && alarm.alarmState == "Investigating"));
      const resolvedAlarms = sortAlarmsDataBySeverity(ackAlarms.filter((alarm: any) => alarm.isAcknowledged && alarm.alarmState == "Resolved"));
      const ignoredAlarms = sortAlarmsDataBySeverity(ackAlarms.filter((alarm: any) => alarm.isAcknowledged && alarm.alarmState == "Ignored"));
      setAcknowledgedAlarms([...investigatingAlarms, ...resolvedAlarms, ...ignoredAlarms]);
    }
  }

  const resolveInvestigatedAlarmData = async (alarmId: any, input: any) => {
    const response = await resolveAlarm(alarmId, input);
    if (!response)
      console.log("Network response was not ok");

    if (response && response.data) {
      const updatedAlarm = {
        ...acknowledgedAlarms.find((a: any) => a.id == alarmId),
        alarmState: response.data.alarmState,
        isAcknowledged: response.data.isAcknowledged,
        alarmComment: response.data.alarmComment,
        acknowledgedFrom: response.data.acknowledgedFrom,
      };

      const newAckList = acknowledgedAlarms.map((a: any) =>
        a.id === alarmId ? updatedAlarm : a
      );

      const investigatingAlarms = sortAlarmsDataBySeverity(newAckList.filter((alarm: any) => alarm.isAcknowledged && alarm.alarmState == "Investigating"));
      const resolvedAlarms = sortAlarmsDataBySeverity(newAckList.filter((alarm: any) => alarm.isAcknowledged && alarm.alarmState == "Resolved"));
      const ignoredAlarms = sortAlarmsDataBySeverity(newAckList.filter((alarm: any) => alarm.isAcknowledged && alarm.alarmState == "Ignored"));
      setAcknowledgedAlarms([...investigatingAlarms, ...resolvedAlarms, ...ignoredAlarms]);
    }
  }

  const removeunacknowledgedAlarm = async (alarmId: any, input:any) => {
    const response = await ignoreAlarm(alarmId,input);
    if (!response)
      console.log("Network response was not ok");

    if (response && response.data) {
      const ackAlarm = unacknowledgedAlarms.find((a: any) => a.id == alarmId);
      ackAlarm.alarmState = response.data.alarmState;
      ackAlarm.isAcknowledged = response.data.isAcknowledged;
      ackAlarm.alarmComment = response.data.alarmComment;
      ackAlarm.acknowledgedFrom = response.data.acknowledgedFrom;
      const newUnackList = unacknowledgedAlarms.filter((a: any) =>
        a.id != alarmId
      );
      const unAckalarms = sortAlarmsDataBySeverity(newUnackList);
      setUnacknowledgedAlarms(unAckalarms);
      const ackAlarms = [ackAlarm, ...acknowledgedAlarms];
      const investigatingAlarms = sortAlarmsDataBySeverity(ackAlarms.filter((alarm: any) => alarm.isAcknowledged && alarm.alarmState == "Investigating"));
      const resolvedAlarms = sortAlarmsDataBySeverity(ackAlarms.filter((alarm: any) => alarm.isAcknowledged && alarm.alarmState == "Resolved"));
      const ignoredAlarms = sortAlarmsDataBySeverity(ackAlarms.filter((alarm: any) => alarm.isAcknowledged && alarm.alarmState == "Ignored"));
      setAcknowledgedAlarms([...investigatingAlarms, ...resolvedAlarms, ...ignoredAlarms]);
    }
  }

  const removeacknowledgedAlarm = async (alarmId: any, input:any) => {
    const response = await ignoreAlarm(alarmId,input);
    if (!response)
      console.log("Network response was not ok");

    if (response && response.data) {
      const updatedAlarm = {
        ...acknowledgedAlarms.find((a: any) => a.id == alarmId),
        alarmState: response.data.alarmState,
        isAcknowledged: response.data.isAcknowledged,
        alarmComment: response.data.alarmComment,
        acknowledgedFrom: response.data.acknowledgedFrom,
      };

      const newAckList = acknowledgedAlarms.map((a: any) =>
        a.id === alarmId ? updatedAlarm : a
      );

      const investigatingAlarms = sortAlarmsDataBySeverity(newAckList.filter((alarm: any) => alarm.isAcknowledged && alarm.alarmState == "Investigating"));
      const resolvedAlarms = sortAlarmsDataBySeverity(newAckList.filter((alarm: any) => alarm.isAcknowledged && alarm.alarmState == "Resolved"));
      const ignoredAlarms = sortAlarmsDataBySeverity(newAckList.filter((alarm: any) => alarm.isAcknowledged && alarm.alarmState == "Ignored"));
      setAcknowledgedAlarms([...investigatingAlarms, ...resolvedAlarms, ...ignoredAlarms]);
    }
  }

  const clearAlarmFilter = () => {
    setSelectedDevices([]);
    setDateRange(null);
  }

  return (
    <div className={styles.panel}>
      <div>
        <div className={styles.header}>
          <h2>Alarms
            <span className={styles.count}>
              <Badge label={(unacknowledgedAlarms.length + acknowledgedAlarms.length).toString()} bgColor="neutral" textColor="dark" />
            </span>
          </h2>
          {(selectedDevices.length > 0 || dateRange != null) && <Tooltip openDelay={100} closeDelay={150} content={<span className="p-2">Clear alarm filter</span>}>
            <ListX className={styles.clearAlarmFilterIcon} onClick={() => { clearAlarmFilter() }} strokeWidth={"2.5px"} size={23} cursor={"pointer"} />
          </Tooltip>}
        </div>

        <div className={styles.selectFilters}>
          <SelectDevicesComboBox devices={devices} selectedDevices={selectedDevices} setSelectedDevices={setSelectedDevices} />

          {dateRange && <Wrap gap="2">
            <ChakraBadge padding="0.25rem 0 0.25rem 0.4rem" display="flex" alignItems="center" gap="0.2rem" fontSize={"0.7rem"}>
              {`${dateRange[0].toLocaleDateString()} ~ ${dateRange[1].toLocaleDateString()}`}
              <CloseButton size={"sm"} boxSize="0.1em" cursor="pointer" onClick={(e) => { e.stopPropagation(); setDateRange(null) }} />
            </ChakraBadge>
          </Wrap>}
          <DateRangePicker value={dateRange} onChange={(value) => { setDateRange(value) }} placeholder="Select Date Range" placement="bottomStart" />
        </div>
      </div>

      <div className={`${styles.downContainer}`}>
        <div className={`${styles.section}`}>
          <Accordion
            title={<h3 className={styles.alarmPanelTitles}>Unacknowledged <span className={styles.sectionCount}>
              <Badge label={unacknowledgedAlarms.length.toString()} bgColor="neutral" textColor="dark" />
            </span></h3>} defaultOpen={true} bgColor='white'>

            <div className={`${styles.alarmsAccordionSection}`}>
              {unacknowledgedAlarms.map(alarm => {
                return (
                  <div className={`${styles.alarmCard}`} key={alarm.id} >
                    <AlarmCard key={alarm.id} removeunacknowledgedAlarm={removeunacknowledgedAlarm} setCurrentExpandedUnackAlarm={setCurrentExpandedUnackAlarm} currentExpandedUnackAlarm={currentExpandedUnackAlarm} alarm={alarm} investigateAlarm={investigateAlarmData} resolveAlarm={resolveAlarmData} />
                  </div>
                );
              })}
            </div>
          </Accordion>
        </div>

        <div className={styles.section}>
          <Accordion
            title={<h3 className={styles.alarmPanelTitles}>Acknowledged <span className={styles.sectionCount}>
              <Badge label={acknowledgedAlarms.length.toString()} bgColor="neutral" textColor="dark" />
            </span></h3>} defaultOpen={true} bgColor='white'
          >
            <div className={`${styles.alarmsAccordionSection} `}>
              {acknowledgedAlarms.map(alarm => {
                return (
                  <div className={`${styles.alarmCard}`} key={alarm.id}>
                    <AlarmCard removeacknowledgedAlarm={removeacknowledgedAlarm} setCurrentExpandedAckAlarm={setCurrentExpandedAckAlarm} currentExpandedAckAlarm={currentExpandedAckAlarm} key={alarm.id} alarm={alarm} investigateAlarm={investigateAlarmData} resolveAlarm={resolveAlarmData} resolveInvestigatedAlarmData={resolveInvestigatedAlarmData} />
                  </div>
                );
              })}
            </div>
          </Accordion>
        </div>
      </div>
    </div>
  );
};

export default AlarmPanel;
```

## components/customcomponents/AlarmPanel/AlarmPanelContent.tsx

```text
import { HStack, Tag } from "@chakra-ui/react";
import styles from "@/styles/scss/AlarmPanel.module.scss";
import { formatRelativeTime } from "@/utils/helperfunctions";
import { MessagesSquare, Settings2, SquareUser } from "lucide-react";


export const DeviceTags = ({ tags, removeTag }: any) => {
  return (
    <HStack gap={"0.5rem"} wrap={"wrap"}>
      {tags.map((tag: any, index: any) => (
        <CustomTag tag={tag.deviceName} index={index} removeTag={removeTag} />
      ))}
    </HStack>
  );
};

export const CustomTag = ({ tag, index, removeTag }: any) => {
  return (
    <Tag.Root key={index} variant="outline" colorPalette={"gray"} color="black" borderRadius="lg" padding="0.2rem 0.6rem" size="md">
      <Tag.Label>{tag}</Tag.Label>
      <Tag.EndElement>
        <Tag.CloseTrigger cursor={"pointer"} onClick={() => removeTag(index)} />
      </Tag.EndElement>
    </Tag.Root>
  )
}


export const AlarmPopUp = ({ setIsAlarmPanelOpen, latestAlarms, totalAlarms }: any) => {
  const severityColors: Record<string, { bg: string; color: string }> = {
    Critical: { bg: 'criticalAlarm', color: 'light' },
    Warning: { bg: 'warningAlarm', color: 'dark' },
    Information: { bg: 'infoAlarm', color: 'light' },
  };

  return (
    <div className={`${styles.alarmPopOverSection} `}>
      {latestAlarms.map((alarm: any) => {
        return (
          <div className={`${styles.alarmPopUpAlarmCard}`} key={alarm.id}>
            <span className={`${styles.severityDot} ${styles[`severityDotBg--${severityColors[alarm.severity].bg}`]}`} />
            <div>
              <p className={styles.message}>{alarm.message}</p>
              <span className={styles.time}>{formatRelativeTime(alarm.raisedAt)}</span>
            </div>
          </div>
        );
      })}
      <button onClick={(event: any) => { event.stopPropagation(); setIsAlarmPanelOpen(true) }} className={styles.viewBtn}>View all</button>
    </div>
  );
}

export const ProfilePopUp = () => {
  return (
    <div className={`${styles.profilePopOverSection} `}>
      <span className={`px-2 ${styles.profilePopUpTitle}`}>Welcome, Premal Kadam</span>
      <p className={`px-2 ${styles.profilePopUpSubTitle}`}>premal.kadam@wonderbiz.in</p>
      <div className={`px-2 py-2`}>
        <ul>
          <li className={styles.profileActionListLi}><SquareUser /> My Account</li>
          <li className={styles.profileActionListLi}><MessagesSquare /> Notifications</li>
          <li className={styles.profileActionListLi}><Settings2 /> Settings</li>
        </ul>
        <button onClick={(event: any) => { event.stopPropagation(); }} className={styles.logoutBtn}>Logout</button>
      </div>
    </div>
  );
}
```

## components/customcomponents/AlarmPanel/CustomModal.tsx

```text
import React, { useRef, useState } from "react";
import styles from "@/styles/scss/AlarmPanel.module.scss";

const CustomModal = ({
  isOpen,
  setIsOpen,
  title,
  footer = true,
  actionFunction = () => {},
}: any) => {  
  const [tempAlarmComment, setTempAlarmComment] = useState<string>("");
  const commentTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  const changeAlarmComment = async (value: string) => {
    if (commentTimeoutRef.current) {
      clearTimeout(commentTimeoutRef.current);
    }

    if (value === "") {
      setTempAlarmComment("");
      return;
    }

    commentTimeoutRef.current = setTimeout(async () => {
      setTempAlarmComment(value);
    }, 200);
  };

  const handleClose = () => setIsOpen(false);

  const handleSave = () => {
    if(tempAlarmComment === "") {
      return;
    }
    actionFunction(tempAlarmComment);
    setIsOpen(false);
  };

  if (!isOpen) return null;

  return (
    <div className={styles.customModalWrapper} data-testid="customModalWrapper" onClick={(e: any) => e.stopPropagation()}>
      <button className={styles.closeBtn} onClick={handleClose}>Ã—</button>
      <h3 className={styles.modalTitle}>{title}</h3>
      <div className={styles.commentInputWrapper}>
        <textarea
          defaultValue={""}
          onChange={(event: any) => changeAlarmComment(event.target.value)}
          className={styles.resolveCommentInput}
          placeholder="Comment"
          maxLength={255}
          rows={2}
        />
      </div>
      {footer && (
        <div className={styles.modalFooter}>
          <button className={styles.cancelBtn} onClick={handleClose}>Cancel</button>
          <button className={styles.saveBtn} onClick={handleSave}>Save</button>
        </div>
      )}
    </div>
  );
};

export default CustomModal;
```

## components/customcomponents/AlarmPanel/SelectDevicesComboBox.tsx

```text
import { Badge, CloseButton, Combobox, Portal, Wrap, createListCollection} from "@chakra-ui/react"
import { useMemo, useState } from "react"

const SelectDevicesComboBox = ({ devices, selectedDevices, setSelectedDevices, multiple = true }: any) => {
  const [searchValue, setSearchValue] = useState("")
 
  // Filter devices based on search input
  const filteredItems = useMemo(
    () =>
      devices.filter((item: any) =>
        item.deviceName.toLowerCase().includes(searchValue.toLowerCase())
      ),
    [searchValue, devices]
  )

  // Prepare collection for Combobox from filtered list
  const collection = useMemo(
    () =>
      createListCollection({
        items: filteredItems.map((device: any) => ({
          value: device.deviceMacId,
          label: device.deviceName,
        })),
      }),
    [filteredItems]
  )
  
  // Convert selected objects to their macIds
  const selectedMacIds = useMemo(
    () => selectedDevices.map((d: any) => d.deviceMacId),
    [selectedDevices]
  )

  const handleValueChange = (details: Combobox.ValueChangeDetails) => {
    console.log("Value changed:", details.value);
    const newSelected = details.value
      .map((macId: string) => devices.find((d: any) => d.deviceMacId === macId))
      .filter(Boolean)
    setSelectedDevices(newSelected)
  }

  return (
    <Combobox.Root
      multiple={multiple}
      // width="320px"
      value={selectedMacIds}
      collection={collection}
      onValueChange={handleValueChange}
      onInputValueChange={(details) => setSearchValue(details.inputValue) }
    >
      <Wrap gap="2">
        {selectedDevices.map((device: any) => (
          <Badge
          data-testid={device.deviceName}
            key={device.deviceMacId}
            padding="0.25rem 0 0.25rem 0.4rem"
            display="flex"
            alignItems="center"
            gap="0.3rem"
            fontSize={"0.7rem"}
          >
            {device.deviceName}
            <CloseButton
              size={"sm"}
              boxSize="0.1em"
              cursor="pointer"
              onClick={(e) => {
                e.stopPropagation()
                setSelectedDevices(
                  selectedDevices.filter(
                    (d: any) => d.deviceMacId !== device.deviceMacId
                  )
                )
              }}
            />
          </Badge>
        ))}
      </Wrap>

      <Combobox.Control>
        <Combobox.Input _placeholder={{ color : "#252525" }} placeholder="Select Devices" padding="0.5rem 0.5rem" />
        <Combobox.IndicatorGroup>
          <Combobox.Trigger data-testid={"comboBoxTrigger"} padding="0.5rem" />
        </Combobox.IndicatorGroup>
      </Combobox.Control>

      <Portal>
        <Combobox.Positioner>
          <Combobox.Content
            backgroundColor="#fff"
            color="#000"
            padding="0.5rem 0rem"
            zIndex="2100"
          >
            <Combobox.ItemGroup>
              <Combobox.ItemGroupLabel padding={"0rem 1rem"} fontWeight={"bold"}>Devices</Combobox.ItemGroupLabel>

              {filteredItems.map((item: any) => (
                <Combobox.Item
                  data-testid={item.deviceMacId}
                  padding={"0.1rem 1rem"}
                  _hover={{ backgroundColor: "#e6e6e6ff" }}
                  key={item.deviceMacId}
                  item={item.deviceMacId}
                >
                  {item.deviceName}
                  <Combobox.ItemIndicator />
                </Combobox.Item>
              ))}

              {filteredItems.length === 0 && (
                <Combobox.Empty>No devices found</Combobox.Empty>
              )}
            </Combobox.ItemGroup>
          </Combobox.Content>
        </Combobox.Positioner>
      </Portal>
    </Combobox.Root>
  )
}

export default SelectDevicesComboBox
```

## components/customcomponents/Badge.tsx

```text
// components/AlarmBadge.tsx
import React from 'react';
import styles from '@/styles/scss/Badge.module.scss';

interface BadgeProps {
  label: string;
  bgColor?: string;
  textColor?: string;
}

const Badge: React.FC<BadgeProps> = ({ label, bgColor, textColor }) => {
  return (
    <span className={`${styles.badge} ${styles[`badgebg--${bgColor}`]} ${styles[`badgetext--${textColor}`]}`} >
      {label}
    </span>
  );
};

export default Badge;
```

## components/customcomponents/FileUploader.tsx

```text
import React, { useRef, useState } from 'react';
import styles from "@/styles/scss/FileUploader.module.scss";
import { Info, X } from 'lucide-react';
import { toast, ToastContainer } from 'react-toastify';
import { uploadFile } from '@/services/deviceservice';
import { Tooltip } from '../ui/tooltip';

const FileUploader = (props: any) => {
    const inputRef = useRef<HTMLInputElement | null>(null);
    const [file, setFile] = useState<File | null>(null);
    const [error, setError] = useState<string>("");

    const handleButtonClick = () => {
        inputRef.current?.click();
    };

    const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        const selectedFile = e.target.files?.[0];
        if (selectedFile) {
            if (selectedFile.type === "application/json") {
                setFile(selectedFile);
                setError("");
            } else {
                setFile(null);
                setError("Only .json files are allowed.");
            }
        }

        if (inputRef.current) {
            inputRef.current.value = "";
        }
    };

    const handleClear = () => {
        setFile(null);
        setError("");
        if (inputRef.current) {
            inputRef.current.value = "";
        }
    };

    const handleSubmit = () => {
        if (file) {
            console.log("Submitting file:", file);
            uploadFileToDisk();
        }
    };

    const uploadFileToDisk = async () => {
        const response = await uploadFile(file!);
        if (response && response.data) {
            setFile(null);
            notify(response.data.message, "success");
            props.setRefreshDeviceDataKey((prev: any) => prev + 1); // Trigger a refresh in parent component
            props.setHardRefreshDeviceDataKey((prev: any) => prev + 1); // Trigger a hard refresh in parent component
        } else {
            if(response && response.response && response.response.data)
                 notify(response.response.data, "error");
            else
                 notify("File upload failed. Please try again.", "error");
        }
    };



    const notify = (msg: string, type: any) => toast(msg, {
        pauseOnHover: true,
        autoClose: 3000,
        theme: "light",
        position: "top-right",
        closeButton: true,
        type: type,
    });

    const handleDownload = () => {
        const link = document.createElement("a");
        link.href = "/template.json"; // file in public folder
        link.download = "template.json"; // optional: enforce download instead of opening
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    };

    return (
        <div >
            <ToastContainer />
            <div className={styles.fileUpload}>

                <input
                    type="file"
                    ref={inputRef}
                    onChange={handleFileChange}
                    className={styles.fileInput}
                    accept=".json"
                />
                <Tooltip openDelay={100} closeDelay={150} content={<span className="p-2">Upload new device json file</span>}>
                    <button onClick={handleButtonClick} className={styles.uploadButton}>
                        Onboard Device
                    </button>
                </Tooltip>


                <div className={styles.fileInfo}>
                    {file ? (
                        <>
                            <span className={styles.fileName}>Selected: {file.name} </span>
                            <X className={styles.clearIcon} onClick={handleClear} />
                        </>
                    ) : (
                        <span className={styles.noFile}>No file selected
                            <Tooltip openDelay={100} closeDelay={150} content={<span className="p-2">Download a template</span>}>
                                <Info onClick={() => { handleDownload() }} className={styles.infoIcon} size={15} />
                            </Tooltip>
                        </span>
                    )}
                </div>
            </div>
            <div style={{marginTop: "0.5rem", display:"flex"}}>
            {file &&
            <Tooltip openDelay={100} closeDelay={150} content={<span className="p-2">Add {file.name}</span>}>
                <button className={styles.submitButton} onClick={handleSubmit}>
                    Submit
                </button>
            </Tooltip>}
            {error && <div className={styles.error}>{error}</div>}
            </div>
        </div>
    );
};

export default FileUploader;
```

## components/customcomponents/Pagination.tsx

```text
import React, { useRef, useState } from "react";
import { ChevronDown, ChevronLeft, ChevronRight, ChevronUp } from "lucide-react";
import styles from "@/styles/scss/Pagination.module.scss";

const Pagination = ({ currentPage, totalPages, pageSize, pageSizeOptions, setCurrentPage, setPageSize, }: any) => {
  const [isSelectOpen, setIsSelectOpen] = useState(false);
  const selectRef = useRef<HTMLSelectElement>(null);
  const handlePageClick = (page: any) => setCurrentPage(page);
  const handlePrev = () => currentPage > 1 && setCurrentPage(currentPage - 1);
  const handleNext = () => currentPage < totalPages && setCurrentPage(currentPage + 1);

  const handlePageSizeChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    setPageSize(Number(e.target.value));
    selectRef.current?.blur();
  }

  const renderPageNumbers = () => {
    const pages: (number | string)[] = [];
    const maxVisible = 5;

    if (totalPages <= maxVisible) {
      for (let i = 1; i <= totalPages; i++) pages.push(i);
    } else {
      const left = Math.max(currentPage - 1, 2);
      const right = Math.min(currentPage + 1, totalPages - 1);
      pages.push(1);
      if (left > 2) pages.push("...");
      for (let i = left; i <= right; i++) pages.push(i);
      if (right < totalPages - 1) pages.push("...");
      pages.push(totalPages);
    }

    return pages.map((page, i) =>
      page === "..." ? (
        <span key={`ellipsis-${i}`} className={styles.ellipsis}>...</span>
      ) : (
        <button
          key={page}
          onClick={() => handlePageClick(page)}
          className={`${styles.paginationButton} ${currentPage === page ? styles.activeButton : ""
            }`}
        >
          {page}
        </button>
      )
    );
  };

  return (
    <div className={styles.paginationContainer}>
      <div className={styles.middleSection}>
        <button data-testid="previous-button" onClick={handlePrev} disabled={currentPage === 1} className={styles.paginationButton}>
          <ChevronLeft size={16} />
        </button>

        {renderPageNumbers()}

        <button data-testid="next-button" onClick={handleNext} disabled={currentPage === totalPages} className={styles.paginationButton}>
          <ChevronRight size={16} />
        </button>

        <div className={styles.selectWrapper}>
          <select
            data-testid="page-size-selector"
            ref={selectRef}
            value={pageSize}
            onChange={handlePageSizeChange}
            className={styles.pageSizeSelector}
            onFocus={() => setIsSelectOpen(true)}
            onBlur={() => setIsSelectOpen(false)}
          >
            {pageSizeOptions.map((size: number) => (
              <option key={size} value={size}>
                {size} / page
              </option>
            ))}
          </select>

          <span className={styles.selectIcon}>
            {isSelectOpen ? <ChevronUp data-testid="pageSize-chevronup" size={18} strokeWidth={"2.5px"} /> : <ChevronDown data-testid="pageSize-chevrondown" size={18} strokeWidth={"2.5px"} />}
          </span>
        </div>
      </div>

      <div className={styles.rightSection}>
        Page {currentPage} of {totalPages}
      </div>
    </div>
  );
};

export default Pagination;
```

## components/customcomponents/Propertypanel/AccordionVisibilityContext.tsx

```text
import React, { createContext, useContext, useState } from "react";

type AccordionContextType = {
  state: Record<string, boolean>;
  register: (path: string, isOpen: boolean) => void;
  toggle: (path: string, openOrClose : boolean) => void;
  getState: (path: string) => boolean | undefined;
};

const AccordionStateContext = createContext<AccordionContextType | null>(null);

export const AccordionStateProvider = ({ children }: { children: React.ReactNode }) => {
  const [state, setState] = useState<Record<string, boolean>>({});

  const register = (path: string, isOpen: boolean) => {
    setState(prev => {
      if (path in prev) return prev;
      return { ...prev, [path]: isOpen };
    });
  };

  const toggle = (path: string, openOrClose : boolean) => {
    setState(prev => ({
      ...prev,
      [path]: openOrClose
    }));
  };

  const getState = (path: string) => {
    return state[path];
  };

  return (
    <AccordionStateContext.Provider value={{ state, register, toggle, getState }}>
      {children}
    </AccordionStateContext.Provider>
  );
};

export const useAccordionState = () => useContext(AccordionStateContext);
```

## components/customcomponents/Propertypanel/KeyValueField.tsx

```text
import React, { useEffect, useState } from "react";
import styles from "@/styles/scss/PropertyPanel.module.scss";

const KeyValueField = ({
  keyName,
  value,
  depth,
  fullPath,
  highlightedPaths,
}: {
  keyName: string;
  value: any;
  depth: number;
  fullPath: string;
  highlightedPaths: string[];
}) => {  
  const [isHighlighted, setIsHighlighted] = useState(false);

  useEffect(() => {
    const isPathHighlighted = highlightedPaths.includes(fullPath);

    if (isPathHighlighted) {
      setIsHighlighted(true);
    }else {
    setIsHighlighted(false);
  }

  }, [highlightedPaths, fullPath]);

  if (typeof value === "boolean") value = value ? "Yes" : "No";

  return (
    <div className={`${styles.kvRow}`}>
      <span className={`${styles.kvKey} ${styles[`depth-${depth}`]}`}>{keyName}</span>
      <span className={`${styles.kvValue} ${isHighlighted ? styles.highlight : ""}`}>{value}</span>
    </div>
  );
};

export function areEqual(prevProps: any, nextProps: any) {
  const wasHighlighted = prevProps.highlightedPaths.includes(prevProps.fullPath);
  const isHighlighted = nextProps.highlightedPaths.includes(nextProps.fullPath);

  const valueChanged = prevProps.value !== nextProps.value;

  return !valueChanged && wasHighlighted === isHighlighted;
}


export default React.memo(KeyValueField, areEqual);
```

## components/customcomponents/Propertypanel/PropertyPanelContent.tsx

```text
import React, { useCallback, useEffect, useMemo, useState } from "react";
import styles from "@/styles/scss/PropertyPanel.module.scss";
import { getLatestAlarmForDevice } from "@/services/alarmservice";
import { formatRelativeTime, getCollapsedAncestorsToHighlight } from "@/utils/helperfunctions";
import { useDeviceAlertSocket } from "@/utils/customhooks/useDeviceAlertSocket";
import { useAccordionState } from "@/components/customcomponents/Propertypanel/AccordionVisibilityContext";
import { renderKeyValueSection, renderObject } from "@/utils/propertypanelfunctions";
import Badge from "@/components/customcomponents/Badge";
import { Alarm, AlarmUpdateMessage } from "@/models/propertyPanelInterfaces";

export const StaticTabContent = React.memo(({ staticProps }: { staticProps: any }) => {
  return (
    <div className={`${styles.propertyPanelTabContent}`}>
      {Object.entries(staticProps).map(([key, value]: any) => {
        if (typeof value === "object" && value !== null)
          return renderObject(key, value, 1, "", [], new Set());
        else
          return (
            <div className={styles.keyValueSection} key={key}>
              {renderKeyValueSection(key, value, 0, "", [])}
            </div>
          );
      })}
    </div>
  );
});

export const HealthTabContent = React.memo(
  ({
    highlightedPaths,
    deviceName,
    setIsAlarmPanelOpen,
    setSelectedDevicePropertyPanel,
    deviceMacId,
    dynamicProps,
  }: any) => {
    const [alarm, setAlarm] = useState<Alarm | null>(null);
    const [totalAlarmsForDevice, setTotalAlarmsForDevice] = useState<number>(0);
    const accordionContext = useAccordionState();

    const collapsedTitlesToHighlight = useMemo(() => {
      return getCollapsedAncestorsToHighlight(highlightedPaths, accordionContext?.state || {});
    }, [highlightedPaths, accordionContext?.state]);

    const handleAlertUpdates = (msg: string) => {
      if (msg == "") {
        setAlarm(null);
        setTotalAlarmsForDevice(0);
        return;
      }
      const incomingUpdates: AlarmUpdateMessage = JSON.parse(msg);
      if (incomingUpdates) {
        setAlarm(incomingUpdates.alarm);
        setTotalAlarmsForDevice(incomingUpdates.totalAlarms);
      } else {
        setAlarm(null);
        setTotalAlarmsForDevice(0);
      }
    };

    useDeviceAlertSocket(deviceMacId, handleAlertUpdates, "ReceivePropertyPanelAlarmUpdates");

    useEffect(() => {
      const fetchLatestAlarmData = async () => {
        const response = await getLatestAlarmForDevice(deviceMacId);
        if (response?.data) {
          setAlarm(response.data.alarm);
          setTotalAlarmsForDevice(response.data.totalAlarms);
        } else {
          setAlarm(null);
          setTotalAlarmsForDevice(0);
        }
      };

      fetchLatestAlarmData();
    }, [deviceMacId]);

    return (
      <div className={styles.propertyPanelTabContent}>
        {alarm && (
          <div className={styles.alarmCard}>
            <div>
              <p className={styles.message}>{alarm.message}</p>
              <span className={styles.time}>{formatRelativeTime(alarm.raisedAt)}</span>
              <div>
                <button
                  onClick={(e) => {
                    e.stopPropagation();
                    setIsAlarmPanelOpen(true);
                    setSelectedDevicePropertyPanel({ deviceMacId, deviceName });
                  }}
                  className={styles.viewBtn}
                >
                  View related alarms
                  <span className="ml-2">
                    <Badge label={totalAlarmsForDevice.toString()} bgColor="neutral" textColor="dark" />
                  </span>
                </button>
              </div>
            </div>
          </div>
        )}

        {Object.entries(dynamicProps).map(([key, value]: any) => {
          if (typeof value === "object" && value !== null)
            return renderObject(key, value, 1, "", highlightedPaths, collapsedTitlesToHighlight);
          else
            return (
              <div className={styles.keyValueSection} key={key}>
                {renderKeyValueSection(key, value, 0, "", highlightedPaths)}
              </div>
            );
        })}
      </div>
    );
  },
  (prevProps, nextProps) => {
    return (
      prevProps.deviceMacId === nextProps.deviceMacId &&
      JSON.stringify(prevProps.highlightedPaths) === JSON.stringify(nextProps.highlightedPaths)
    );

  }
);
```

## components/customcomponents/Propertypanel/PropertyPannel.tsx

```text
import React, { useCallback, useEffect, useRef, useState } from "react";
import Accordion from "../Accordion";
import { useDeviceDetailSocket } from "@/utils/customhooks/useDeviceDetailSocket";
import TabList from "./TabList";
import { HealthTabContent, StaticTabContent } from "./PropertyPanelContent";
import { getPropertyPanelData } from "@/services/deviceservice";
import styles from "@/styles/scss/PropertyPanel.module.scss";
import { getChangedPaths } from "@/utils/deepDiff";
import ComboBox from "@/components/customcomponents/AlarmPanel/SelectDevicesComboBox";
import { AccordionStateProvider } from "./AccordionVisibilityContext";
import { deepMerge } from "@/utils/propertypanelfunctions";
import { DeviceDetailUpdate, DeviceNameMac, PropertyPanelData } from "@/models/propertyPanelInterfaces";


const PropertyPanel = ({ setCurrentDeviceId, devicesNameMacList, setIsAlarmPanelOpen, setSelectedDevicePropertyPanel, currentDeviceId, activeTab, setActiveTab }: any) => {
    const [propertyPanelData, setPropertyPanelData] = useState<PropertyPanelData | null>(null);
    const [highlightedPaths, setHighlightedPaths] = useState<string[]>([]);
    const highlightTimeoutRef = useRef<NodeJS.Timeout | null>(null);
    const [shouldConnectSignalR, setShouldConnectSignalR] = useState<boolean>(true);
    const [selectedDevices, setSelectedDevices] = useState<DeviceNameMac[]>([]);

    const handleUpdate = useCallback((msg: any) => {
        const incomingDevicesDetails: DeviceDetailUpdate = JSON.parse(msg);

        setPropertyPanelData((prev: any) => {
            if (!prev) return prev;

            const merged = {
                ...prev,
                dynamicProperties: deepMerge(prev.dynamicProperties, incomingDevicesDetails)
            };

            const changed = getChangedPaths(prev.dynamicProperties, incomingDevicesDetails);
            setHighlightedPaths(changed);

            if (highlightTimeoutRef.current) {
                clearTimeout(highlightTimeoutRef.current);
            }

            highlightTimeoutRef.current = setTimeout(() => {
                setHighlightedPaths([]);
            }, 3000);

            return merged;
        });
    }, []);

    useEffect(() => {
        return () => {
            if (highlightTimeoutRef.current) {
                clearTimeout(highlightTimeoutRef.current);
            }
        };
    }, []);


    useEffect(() => {
        if (selectedDevices.length == 1) {
            const deviceId = selectedDevices[0].deviceMacId;
            setCurrentDeviceId(deviceId);
            // setCurrentDeviceFileName(deviceFileNames[deviceId!] || null)
        }
    }, [selectedDevices]);

    useDeviceDetailSocket(currentDeviceId, handleUpdate, shouldConnectSignalR);

    useEffect(() => {
        if (currentDeviceId) {
            const fetchData = async () => {
                const response = await getPropertyPanelData(currentDeviceId);
                if (!response)
                    console.log("Network response was not ok");

                if (response && response.data) {
                    setPropertyPanelData(response.data);
                    console.log(response.data);
                    
                }
            };
            fetchData();
        }
    }, [currentDeviceId]);

    const changeActiveTab = (tab: any) => {
        tab === "Static" ? setShouldConnectSignalR(false) : setShouldConnectSignalR(true);
        setActiveTab(tab);
    }

    function renderSelectDeviceDropdown() {
        return (
            <div className={styles.selectDeviceDropdown}>
                <span>Select device </span>
                <ComboBox
                    devices={devicesNameMacList}
                    selectedDevices={selectedDevices}
                    setSelectedDevices={setSelectedDevices}
                    multiple={false}
                />
            </div>
        )
    }

    function renderPropertyPanelData(data: any) {
        if (!data || Object.keys(data).length === 0)
            return renderSelectDeviceDropdown();

        return (
            <div className={`${styles.propertyPanelContainer} pt-2 pb-2`}>
                {/* <span className={`pl-2`}>{PropertyPanelData.name} : {PropertyPanelData.type}</span><br /> */}
                <div className={`pl-2 ${styles.propertyPanelHeadingContainer}`}>
                    <span className={styles.deviceTitle}>{propertyPanelData?.name}</span>
                    <span className={styles.deviceSubTitle}>{propertyPanelData?.type}</span>
                </div>
                <div className={`mt-2 ${styles.propertyPanelMainContent}`}>
                    <AccordionStateProvider>
                        <Accordion keyPath={activeTab} isTabList={true} title={<TabList highlightedPaths={highlightedPaths} activeTab={activeTab} setActiveTab={changeActiveTab} />} defaultOpen={true} bgColor=''>
                            {(activeTab === "Static" && propertyPanelData?.staticProperties) ?
                                <StaticTabContent staticProps={propertyPanelData.staticProperties} />
                                : <HealthTabContent highlightedPaths={highlightedPaths} deviceName={propertyPanelData?.name} setSelectedDevicePropertyPanel={setSelectedDevicePropertyPanel} setIsAlarmPanelOpen={setIsAlarmPanelOpen} deviceMacId={propertyPanelData?.macId} dynamicProps={propertyPanelData?.dynamicProperties} />}
                        </Accordion>
                    </AccordionStateProvider>
                </div>
            </div>
        );
    }

    return (
        < >
            {renderPropertyPanelData(propertyPanelData)}
        </>
    );
};

export default PropertyPanel;
```

## components/customcomponents/Propertypanel/TabList.tsx

```text
import styles from "@/styles/scss/PropertyPanel.module.scss";
import { useAccordionState } from "./AccordionVisibilityContext";

const TabList = ({ highlightedPaths, activeTab, setActiveTab }: any) => {
    const tabs = ["Static", "Health"];
    const accordionContext = useAccordionState();
    
    const changeActiveTab = (tab: string) => {
        setActiveTab(tab);
        if (accordionContext?.state) {
            accordionContext?.toggle(tab!,true);
        }
    };    

    const shouldHighlightTitle = (activeTab=="Health" && highlightedPaths.length > 0) && accordionContext?.getState(activeTab) === false;

    return (
        <ul className={styles.tabListUL}>
            {tabs.map((tab) => (
                <li key={tab}
                    onClick={(event: any) => {
                        event.stopPropagation();
                        changeActiveTab(tab);
                    }}
                    className={`${styles.tabListLi} ${activeTab === tab ? styles.tabListLiActive : null} ${shouldHighlightTitle && tab == "Health" ? styles.highlightedTitle : ""}`}
                >
                    {tab}
                </li>
            ))}
        </ul>
    );
}

export default TabList;
```

## components/customcomponents/ReactDiagramWrapper.tsx

```text
import * as go from 'gojs';
import { ReactDiagram } from 'gojs-react';
import { useEffect, useRef } from 'react';
import { ReactDiagram as GoDiagram } from 'gojs-react';

// TypeScript JSX type cast workaround
const Diagram = GoDiagram as unknown as React.FC<any>;

interface DiagramProps {
    nodeDataArray: Array<go.ObjectData>;
    linkDataArray: Array<go.ObjectData>;
    modelData: go.ObjectData;
    skipsDiagramUpdate: boolean;
    onDiagramEvent: (e: go.DiagramEvent) => void;
    onModelChange: (e: go.IncrementalData) => void;
    /** New: external customizer for diagram setup */
    onInitDiagram?: (diagram: go.Diagram) => void;
}

export const ReactDiagramWrapper = (props: DiagramProps) => {
    console.log("rerendered ReactDiagramWrapper");

    const diagramRef = useRef<ReactDiagram>(null);

    // Add/remove listeners
    useEffect(() => {
        if (!diagramRef.current) return;
        const diagram = diagramRef.current.getDiagram();

        if (diagram instanceof go.Diagram) {
            diagram.addDiagramListener('ChangedSelection', props.onDiagramEvent);
        }
        return () => {
            if (diagram instanceof go.Diagram) {
                diagram.removeDiagramListener('ChangedSelection', props.onDiagramEvent);
            }
        };
    }, []);


    /** Main initDiagram function used by ReactDiagram */
    const initDiagram = (): go.Diagram => {
        const diagram = new go.Diagram({
            "undoManager.isEnabled": true,
            "toolManager.mouseWheelBehavior": go.WheelMode.Zoom,
            allowHorizontalScroll: false,
            allowVerticalScroll: true,
            autoScrollRegion: 0, // disables auto-scrolling when dragging near edges
            model: new go.GraphLinksModel({
                linkKeyProperty: "key",
                // ðŸ‘‡ tell GoJS to use "parent" property for grouping
                nodeGroupKeyProperty: "parent",
                // ðŸ‘‡ also enable groups in model
                nodeIsGroupProperty: "isGroup",
            }),
        });

        // Wait until layout completes so viewport bounds are correct
        diagram.addDiagramListener("InitialLayoutCompleted", () => {
            diagram.nodes.each(node => {
                node.dragComputation = (part, newLoc) => {
                    const vb = diagram.viewportBounds.copy(); // visible area in document coords
                    const nb = part.actualBounds;

                    // Clamp so node stays fully inside visible area
                    const clampedX = Math.max(vb.x, Math.min(newLoc.x, vb.right - nb.width));
                    const clampedY = Math.max(vb.y, Math.min(newLoc.y, vb.bottom - nb.height));

                    return new go.Point(clampedX, clampedY);
                };
            });
        });

        // ðŸ‘‡ Allow external customization (layouts, templates, etc.)
        if (props.onInitDiagram) {
            props.onInitDiagram(diagram);
        }
        else {
            // Default fallback template (if none provided)
            diagram.nodeTemplate = new go.Node('Auto')
                .bindTwoWay('location', 'loc', go.Point.parse, go.Point.stringify)
                .add(
                    new go.Shape('RoundedRectangle', {
                        name: 'SHAPE',
                        fill: 'white',
                        strokeWidth: 1,
                        portId: '',
                        fromLinkable: true,
                        toLinkable: true,
                        cursor: 'pointer',
                    }).bind('fill', 'color'),
                    new go.TextBlock({
                        margin: 8,
                        editable: true,
                        font: '400 .875rem Roboto, sans-serif',
                    }).bindTwoWay('text')
                );

            diagram.linkTemplate = new go.Link()
                .add(new go.Shape(), new go.Shape({ toArrow: 'Standard' }));
        }

        return diagram;
    };


    return (
        <Diagram
            ref={diagramRef}
            divClassName="diagram-component"
            initDiagram={initDiagram}
            nodeDataArray={props.nodeDataArray}
            linkDataArray={props.linkDataArray}
            modelData={props.modelData}
            onModelChange={props.onModelChange}
            skipsDiagramUpdate={props.skipsDiagramUpdate}
        />
    );
};
```

## components/customcomponents/Settings.tsx

```text
import { Popover, Portal, Separator, Text } from "@chakra-ui/react"
import { Tooltip } from "../ui/tooltip";
import { Menu } from "lucide-react";
import styles from "@/styles/scss/Home.module.scss";
import { getAlarmToggleValue, setAlarmToggleValue } from "@/services/deviceservice";
import { useEffect, useState } from "react";
import SwitchComponent from "../chakrauicomponents/SwitchComponent";
import FileUploader from "./FileUploader";

const Settings = (props: any) => {

    const [simulateAlarms, setSimulateAlarms] = useState(false);

    useEffect(() => {
        const fetchAlarmToggleStatus = async () => {
            const response = await getAlarmToggleValue();
            if (!response)
                console.log("Network response was not ok");

            if (response && response.data) {
                console.log(response.data, typeof response.data);

                setSimulateAlarms(response.data.alarmEnabled);
            }
        };
        fetchAlarmToggleStatus();
    }, []);

    const toggleAlarmSimulation = () => {
        const setAlarmToggleStatus = async () => {
            const response = await setAlarmToggleValue(!simulateAlarms);
            if (!response)
                console.log("Network response was not ok");

            if (response && response.data) {
                setSimulateAlarms(response.data.alarmEnabled);
            }
        };
        setAlarmToggleStatus();
    };

    return (
        <Popover.Root positioning={{ placement: "bottom-end" }}>
            <Popover.Trigger asChild>
                <div >
                    <Tooltip openDelay={100} closeDelay={150} content={<span className="p-2">Settings</span>}>
                        <Menu className={styles.deviceRefreshIcon} onClick={() => { }} strokeWidth={"2.5px"} size={25} cursor={"pointer"} />
                    </Tooltip>
                </div>
            </Popover.Trigger>

            <Portal>
                <Popover.Positioner>
                    <Popover.Content style={{ width: "100%" }}>
                        <Popover.Body>
                            <div style={{ padding: "0.5rem 0.8rem" }}>
                                <table style={{ borderCollapse: "collapse", width: "100%" }}>
                                    <tbody>
                                        <tr style={{ borderBottom: "0.8rem solid transparent" }}>
                                            <td style={{ paddingRight: "0.5rem" }}>
                                                <Text textStyle="sm">
                                                    Simulate Alarms
                                                </Text>
                                            </td>
                                            <td>
                                                <SwitchComponent tooltip={`${simulateAlarms ? 'Stop Alarms' : 'Start Alarms'}`} enabled={simulateAlarms} toggle={toggleAlarmSimulation} />
                                            </td>
                                        </tr>
                                        <tr style={{ borderBottom: "0.8rem solid transparent" }}>
                                            <td style={{ paddingRight: "0.5rem" }}>
                                                <Text textStyle="sm">
                                                    {!props.isDiagramView ? 'Toggle Diagram View' : 'Toggle Table View'}
                                                </Text>
                                            </td>
                                            <td>
                                                <SwitchComponent tooltip={`Toggle View`} enabled={props.isDiagramView} toggle={props.setDeviceView} />
                                            </td>
                                        </tr>
                                    </tbody>
                                </table>
                                <Separator />
                                <div style={{marginTop:"0.8rem"}}>
                                <FileUploader setHardRefreshDeviceDataKey={props.setHardRefreshDeviceDataKey} setRefreshDeviceDataKey={props.setRefreshDeviceDataKey} />
                                </div>
                            </div>
                        </Popover.Body>
                    </Popover.Content>
                </Popover.Positioner>
            </Portal>
        </Popover.Root>
    )
}
export default Settings;
```

## components/customcomponents/SideBar.tsx

```text
import React, { ReactNode, useState } from "react";
import styles from "@/styles/scss/Sidebar.module.scss";
import { ChevronLeft, ChevronRight, RectangleVertical, X } from "lucide-react";
import { Tooltip } from "../ui/tooltip";

type SidebarProps = {
  position?: "left" | "right";
  children?: ReactNode;
  isOpen?: boolean;
  setIsOpen?: (isOpen: boolean) => void;
  closeSidebar? : () => void;
  closeIconMsg : any;
  openIconMsg : any;
  zIndex? : string;
};

const Sidebar = ({zIndex="2000", closeIconMsg, openIconMsg, position = "left", children, isOpen = false, setIsOpen = (isOpen: boolean) => { }, closeSidebar = () => {}}: SidebarProps) => {
  return (
    <div className={`${styles.sidebar} ${styles[position]} ${isOpen ? styles.open : ""} ${styles[zIndex]}`}>
      {position=="left" ? 
      isOpen ? <button data-testid="Leftsidebar-close-button" className={styles.closeButton} onClick={() => setIsOpen(false)}> 
                <Tooltip openDelay={100} closeDelay={150} content={<span className="p-2">{closeIconMsg}</span>}>
                  <X className={styles.sidebarCloseIcon} size={28} />
                </Tooltip></button> 
                : 
                <Tooltip openDelay={100} closeDelay={150} content={<span className="p-2">{openIconMsg}</span>}>
                  <div data-testid="Leftsidebar-open-button" onClick={() => setIsOpen(true)} className={`${styles.closeIcon} ${styles.rightCloseIcon}`} > <ChevronRight/> </div>
                </Tooltip>
                 :
      isOpen ? <button data-testid="Rightsidebar-close-button" className={styles.closeButton} onClick={() => closeSidebar()}>
                <Tooltip openDelay={100} closeDelay={150} content={<span className="p-2">{closeIconMsg}</span>}>
                  <X className={styles.sidebarCloseIcon} size={28} />
                </Tooltip></button> 
                 : 
                 <Tooltip openDelay={100} closeDelay={150} content={<span className="p-2">{openIconMsg}</span>}>
                  <div data-testid="Rightsidebar-open-button" onClick={() => setIsOpen(true)} className={`${styles.closeIcon} ${styles.leftCloseIcon}`} > <ChevronLeft/> </div> 
                </Tooltip>
                 
      }
      {children}
    </div>
  );
};

export default Sidebar;
```

## components/customcomponents/Table/TableComponent.tsx

```text
import React, { useEffect, useMemo, useState } from "react";
import { useReactTable, getCoreRowModel, getSortedRowModel, flexRender, ColumnDef, SortingState, } from "@tanstack/react-table";
import styles from "@/styles/scss/Table.module.scss";
import TableRow from "@/components/customcomponents/Table/TableRow";
import { ArrowDown, ArrowUp } from "lucide-react";
import Pagination from "../Pagination";
import { capitalizeFirstLetter, formatDateTime } from "@/utils/helperfunctions";

const TableComponent = ({ currentDeviceId, sorting, setSorting, refreshDeviceDataKey, updatedFieldsMap, currentPage, setCurrentPage, totalPages, pageSize, setPageSize, data, setIsPropertyPanelOpen }: any) => {
  if (!data || data.length === 0)
    return <p className="px-2">No data available.</p>;

  // Columns definition
  const columns = useMemo<ColumnDef<any, any>[]>(() => {
    // const excludedFields = ['lastUpdated'];

    return Object.keys(data[0])
      // .filter((key) => !excludedFields.includes(key))
      .map((key) => ({
        accessorKey: key,
        header: () => capitalizeFirstLetter(key),
        cell: (info) => {
          const val = info.getValue();
          return key === 'lastUpdated' ? formatDateTime(val) : val;
        },
        enableSorting: true,
      }));
  }, [data]);

  // Table instance
  const table = useReactTable({
    data,
    columns,
    manualSorting: true,
    state: {
      sorting,
    },
    onSortingChange: setSorting,
    getCoreRowModel: getCoreRowModel(),
    getSortedRowModel: getSortedRowModel(),
  });

  return (
    <>
      <div className={`${styles.tableWrapper}`}>
        <div className={`${styles.tableHeader} `}>
          <table className={styles.table}>
            <thead>
              {table.getHeaderGroups().map((headerGroup) => (
                <tr key={headerGroup.id} className={styles.row}>
                  {headerGroup.headers.map((header) => {
                    const isSortable = header.column.getCanSort();
                    const sortDir = header.column.getIsSorted(); // false | 'asc' | 'desc'
                    return (
                      <th key={header.id}
                        className={styles.header}
                        onClick={isSortable ? header.column.getToggleSortingHandler() : undefined}
                      >
                        <div className={styles.sortIcon}>
                          {flexRender(header.column.columnDef.header, header.getContext())}
                          {isSortable && (sortDir === "asc" ? (<ArrowUp size={16} />) : sortDir === "desc" ? (<ArrowDown size={16} />) : null)}
                        </div>
                      </th>
                    );
                  })}
                </tr>
              ))}
            </thead>
          </table>
        </div>

        <div className={styles.tableBody}>
          <table className={styles.table}>
            <tbody>
              {table.getRowModel().rows.map((row) => (<TableRow currentDeviceId={currentDeviceId} refreshDeviceDataKey={refreshDeviceDataKey} updatedFieldsMap={updatedFieldsMap} key={row.id} row={row} setIsPropertyPanelOpen={setIsPropertyPanelOpen} />))}
            </tbody>
          </table>
        </div>
      </div>
      <Pagination setPageSize={setPageSize} currentPage={currentPage} setCurrentPage={setCurrentPage} totalPages={totalPages} pageSize={pageSize} pageSizeOptions={[3, 5, 10]} />
    </>
  );
};

export default TableComponent;
```

## components/customcomponents/Table/TableRow.tsx

```text
import React, { useEffect, useState } from "react";
import styles from "@/styles/scss/Table.module.scss";
import { flexRender, Row } from "@tanstack/react-table";

type Props = {
  row: Row<any>;
  setIsPropertyPanelOpen: (id: string) => void;
  updatedFieldsMap: { [macId: string]: string[] } | null;
  refreshDeviceDataKey?: any;
  currentDeviceId : any;
};

const TableRow = React.memo(
  ({ currentDeviceId, refreshDeviceDataKey = undefined, updatedFieldsMap, row, setIsPropertyPanelOpen }: Props) => {
    const rowData = row.original;
    const macId = rowData.macId;

    const [localUpdatedFields, setLocalUpdatedFields] = useState<any[]>([]);

    useEffect(() => {
      const updatedFields = updatedFieldsMap?.[macId];
      
      if (updatedFields && updatedFields.length > 0) {
        setLocalUpdatedFields(updatedFields);

        const timer = setTimeout(() => {
          setLocalUpdatedFields([]);
        }, 3000);

        return () => clearTimeout(timer);
      }else{
        setLocalUpdatedFields([])
      }
    }, [updatedFieldsMap?.[macId]]);

    useEffect(() => {  
      if (refreshDeviceDataKey)    
        setLocalUpdatedFields([]);
    }, [refreshDeviceDataKey]);

    return (
      <tr
        className={`${localUpdatedFields.length > 0 ? styles.highlightedRow : ""} ${styles.row} ${currentDeviceId && currentDeviceId == macId ? styles.rowSelected : ""}`}
        key={macId}
        onClick={() => setIsPropertyPanelOpen(macId)}
      >
        {row.getVisibleCells().map((cell: any) => {
          const columnId = cell.column.id;
          const isUpdated = localUpdatedFields.includes(columnId);
          
          return (
            <td
              key={cell.id}
              className={`${styles.cell} ${isUpdated ? styles.highlightedCell : ""}`} >
              {flexRender(cell.column.columnDef.cell, cell.getContext())}
            </td>
          );
        })}
      </tr>
    );
  },
  areEqual
);

export function areEqual(prevProps: Props, nextProps: Props) {
  const prevRow = prevProps.row.original;
  const nextRow = nextProps.row.original;

  if (prevProps.refreshDeviceDataKey !== nextProps.refreshDeviceDataKey) {
    return false; // re-render on refresh
  }

  if (prevProps.currentDeviceId !== nextProps.currentDeviceId) {
    return false;
  }

  if (
    prevRow.macId !== nextRow.macId ||
    prevRow.status !== nextRow.status ||
    prevRow.connectivity !== nextRow.connectivity
  ) {
    return false;
  }

  // Compare updatedFieldsMap contents
  const prevFields = prevProps.updatedFieldsMap?.[prevRow.macId] ?? [];
  const nextFields = nextProps.updatedFieldsMap?.[nextRow.macId] ?? [];

  if (prevFields.length !== nextFields.length) return false;
  for (let i = 0; i < prevFields.length; i++) {
    if (prevFields[i] !== nextFields[i]) return false;
  }

  return true;
}

export default TableRow;
```

## components/ui/color-mode.tsx

```text
import type { IconButtonProps, SpanProps } from "@chakra-ui/react"
import { ClientOnly, IconButton, Skeleton, Span } from "@chakra-ui/react"
import { ThemeProvider, useTheme } from "next-themes"
import type { ThemeProviderProps } from "next-themes"
import * as React from "react"
import { LuMoon, LuSun } from "react-icons/lu"

export interface ColorModeProviderProps extends ThemeProviderProps {}

export function ColorModeProvider(props: ColorModeProviderProps) {
  return (
    <ThemeProvider defaultTheme="light" attribute="class" disableTransitionOnChange {...props} />
  )
}

export type ColorMode = "light" | "dark"

export interface UseColorModeReturn {
  colorMode: ColorMode
  setColorMode: (colorMode: ColorMode) => void
  toggleColorMode: () => void
}

export function useColorMode(): UseColorModeReturn {
  const { resolvedTheme, setTheme, forcedTheme } = useTheme()
  const colorMode = forcedTheme || resolvedTheme
  const toggleColorMode = () => {
    setTheme(resolvedTheme === "dark" ? "light" : "dark")
  }
  return {
    colorMode: colorMode as ColorMode,
    setColorMode: setTheme,
    toggleColorMode,
  }
}

export function useColorModeValue<T>(light: T, dark: T) {
  const { colorMode } = useColorMode()
  return colorMode === "dark" ? dark : light
}

export function ColorModeIcon() {
  const { colorMode } = useColorMode()
  return colorMode === "dark" ? <LuMoon /> : <LuSun />
}

interface ColorModeButtonProps extends Omit<IconButtonProps, "aria-label"> {}

export const ColorModeButton = React.forwardRef<
  HTMLButtonElement,
  ColorModeButtonProps
>(function ColorModeButton(props, ref) {
  const { toggleColorMode } = useColorMode()
  return (
    <ClientOnly fallback={<Skeleton boxSize="8" />}>
      <IconButton
        onClick={toggleColorMode}
        variant="ghost"
        aria-label="Toggle color mode"
        size="sm"
        ref={ref}
        {...props}
        css={{
          _icon: {
            width: "5",
            height: "5",
          },
        }}
      >
        <ColorModeIcon />
      </IconButton>
    </ClientOnly>
  )
})

export const LightMode = React.forwardRef<HTMLSpanElement, SpanProps>(
  function LightMode(props, ref) {
    return (
      <Span
        color="fg"
        display="contents"
        className="chakra-theme light"
        colorPalette="gray"
        colorScheme="light"
        ref={ref}
        {...props}
      />
    )
  },
)

export const DarkMode = React.forwardRef<HTMLSpanElement, SpanProps>(
  function DarkMode(props, ref) {
    return (
      <Span
        color="fg"
        display="contents"
        className="chakra-theme dark"
        colorPalette="gray"
        colorScheme="dark"
        ref={ref}
        {...props}
      />
    )
  },
)
```

## components/ui/provider.tsx

```text
import { ChakraProvider, defaultSystem } from "@chakra-ui/react"
import {
  ColorModeProvider,
  type ColorModeProviderProps,
} from "./color-mode"

export function Provider(props: ColorModeProviderProps) {
  return (
    <ChakraProvider value={defaultSystem}>
      <ColorModeProvider {...props} />
    </ChakraProvider>
  )
}
```

## components/ui/tooltip.tsx

```text
import { Tooltip as ChakraTooltip, Portal } from "@chakra-ui/react"
import * as React from "react"

export interface TooltipProps extends ChakraTooltip.RootProps {
  showArrow?: boolean
  portalled?: boolean
  portalRef?: React.RefObject<HTMLElement>
  content: React.ReactNode
  contentProps?: ChakraTooltip.ContentProps
  disabled?: boolean
}

export const Tooltip = React.forwardRef<HTMLDivElement, TooltipProps>(
  function Tooltip(props, ref) {
    const {
      showArrow,
      children,
      disabled,
      portalled = true,
      content,
      contentProps,
      portalRef,
      ...rest
    } = props

    if (disabled) return children

    return (
      <ChakraTooltip.Root {...rest} >
        <ChakraTooltip.Trigger asChild>{children}</ChakraTooltip.Trigger>
        <Portal disabled={!portalled} container={portalRef}>
          <ChakraTooltip.Positioner>
            <ChakraTooltip.Content background={"white"} color="black" padding={"0.2rem 0.3rem"} zIndex={2100} ref={ref} {...contentProps}>
              {showArrow && (
                <ChakraTooltip.Arrow>
                  <ChakraTooltip.ArrowTip />
                </ChakraTooltip.Arrow>
              )}
              {content}
            </ChakraTooltip.Content>
          </ChakraTooltip.Positioner>
        </Portal>
      </ChakraTooltip.Root>
    )
  },
)
```

## models/allInterfaces.ts

```typescript
// -------------------------
// Device-related interfaces
// -------------------------
export interface Device {
  macId: string;
  name: string;
  status: string;
  connectivity: string;
  lastUpdated: string; // ISO date string
  type: string;
}

export interface DeviceUpdateMessage {
  MacId: string;
  Status?: string;
  Connectivity?: string;
  LastUpdated?: string;
}

export interface DeviceFileNameMap {
  [macId: string]: string;
}

export interface DeviceNameMac {
  macId: string;
  name: string;
}

// -------------------------
// Alarm-related interfaces
// -------------------------
export interface Alarm {
  id: string;
  message: string;
  severity: string;
  timestamp: string; // ISO date string
}

export interface AlarmResponse {
  alarms: Alarm[];
  totalAlarms: number;
}

// -------------------------
// Table & Highlight Map
// -------------------------
export interface UpdatedFieldsMap {
  [macId: string]: string[];
}

// -------------------------
// API responses
// -------------------------
export interface PaginatedDeviceResponse {
  data: Device[];
  totalCount: number;
}

export interface MacIdToFileNameResponse {
  data: DeviceFileNameMap;
}

export interface DeviceNameMacListResponse {
  data: DeviceNameMac[];
}

// -------------------------
// React Diagram interfaces
// -------------------------
export interface AppState {
  devices: Device[];
  nodeDataArray: go.ObjectData[];
  linkDataArray: go.ObjectData[];
  modelData: go.ObjectData;
  skipsDiagramUpdate: boolean;
  selectedDevice: Device | null;
}



// ***************************************************************************
```

## models/propertyPanelInterfaces.ts

```typescript
// -------------------------
// Property Panel Data Types
// -------------------------
export interface StaticProperties {
  [key: string]: string | number | boolean | null; // You can make this stricter if you know exact fields
}

export interface DynamicProperties {
  [key: string]: any; // This can be typed more strictly if you know the exact observable schema
}

export interface PropertyPanelData {
  name: string;
  type: string;
  macId: string;
  staticProperties: StaticProperties;
  dynamicProperties: DynamicProperties;
}

// WebSocket incoming data (device detail updates)
export interface DeviceDetailUpdate {
  [key: string]: any; // The WebSocket sends only updated dynamic properties
}

// Dropdown device type
export interface DeviceNameMac {
  macId: string;
  name: string;
  deviceMacId?: string; // In ComboBox you seem to use `deviceMacId`
}


export interface Alarm {
  message: string;
  raisedAt: string;
}

export interface AlarmUpdateMessage {
  alarm: Alarm | null;
  totalAlarms: number;
}
```

## pages/index.tsx

```text
// adding comment to test pipeline v2
// testing branch rules for pr
//tesing for sonarqube in pipeline v2
//tesing for sonarqube and coverity in pipeline v2
//tesing for generic pipeline pipeline v38
import { Geist, Geist_Mono } from "next/font/google";
import Badge from "@/components/customcomponents/Badge";
import Sidebar from "@/components/customcomponents/SideBar";
import PropertyPanel from "@/components/customcomponents/Propertypanel/PropertyPannel";
import TableComponent from "@/components/customcomponents/Table/TableComponent";
import AlarmPanel from "@/components/customcomponents/AlarmPanel/AlarmPanel";
import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import { useDevicesTopDataSocket } from "@/utils/customhooks/useDevicesTopDataSocket";
import { BellRing, Download, ListX, Menu, Repeat, UserPen } from "lucide-react";
import { getAlarmToggleValue, getAllDataRefereshedFromCache, getDeviceMetadata, getDeviceMetadataPaginatedandSorted, getDevicesNameMacIdList, getDevicesTopLevelData, getMacIdToFileNameMap, getSearchedDeviceMetadataPaginated, setAlarmToggleValue } from "@/services/deviceservice";
import styles from "@/styles/scss/Home.module.scss";
import PopOver from "@/components/chakrauicomponents/PopOver";
import { AlarmPopUp, ProfilePopUp } from "@/components/customcomponents/AlarmPanel/AlarmPanelContent";
import { getLatestAlarms } from "@/services/alarmservice";
import { useDeviceAlertSocket } from "@/utils/customhooks/useDeviceAlertSocket";
import { SortingState } from "@tanstack/react-table";
import { Tooltip } from "@/components/ui/tooltip";
import FileUploader from "@/components/customcomponents/FileUploader";
import { Alarm, AlarmResponse, AppState, Device, DeviceFileNameMap, DeviceNameMac, DeviceUpdateMessage, UpdatedFieldsMap } from "@/models/allInterfaces";
import { Button, Input, Popover, Portal, Text } from "@chakra-ui/react"
import * as go from "gojs";
import { useImmer } from "use-immer";
import { ReactDiagramWrapper } from "@/components/customcomponents/ReactDiagramWrapper";
import { formatDateTime, getIcon } from "@/utils/helperfunctions";
import Settings from "@/components/customcomponents/Settings";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export default function Home() {
  const [deviceData, setDeviceData] = useState<Device[]>([]);
  const [state, updateState] = useImmer<AppState>({
    devices: [],
    nodeDataArray: [],
    linkDataArray: [],
    modelData: { canRelink: false },
    skipsDiagramUpdate: false,
    selectedDevice: null
  });
  // const [deviceFileNames, setDeviceFileNames] = useState<DeviceFileNameMap>({});
  const initialTabState = "Health"; // Default active tab
  const [activeTab, setActiveTab] = useState(initialTabState);
  const [isPropertyPanelOpen, setIsPropertyPanelOpen] = useState<boolean>(false);
  const [currentDeviceId, setCurrentDeviceId] = useState<string | null>(null);
  // const [currentDeviceFileName, setCurrentDeviceFileName] = useState<string | null>(null);
  const [isAlarmPanelOpen, setIsAlarmPanelOpen] = useState<boolean>(false);
  const [isAlarmPopOverOpen, setIsAlarmPopOverOpen] = useState<boolean>(false);
  const [isProfilePopOverOpen, setIsProfilePopOverOpen] = useState<boolean>(false);
  const [latestAlarms, setLatestAlarms] = useState<Alarm[]>([]);
  const [totalAlarms, setTotalAlarms] = useState<number>(0);
  const [selectedDevicePropertyPanel, setSelectedDevicePropertyPanel] = useState<any>(null);
  const [totalCount, setTotalCount] = useState(0);
  const [currentPage, setCurrentPage] = useState(1);
  const [pageSize, setPageSize] = useState(10);
  const [totalPages, setTotalPages] = useState(0);
  const [refreshDeviceDataKey, setRefreshDeviceDataKey] = useState(0);
  const [hardRefreshDeviceDataKey, setHardRefreshDeviceDataKey] = useState(0);
  const [searchInput, setSearchInput] = useState<any>(null);
  const [updatedFieldsMap, setUpdatedFieldsMap] = useState<UpdatedFieldsMap | null>(null);
  const highlightTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const [devicesNameMacList, setDevicesNameMacList] = useState<DeviceNameMac[] | null>(null); const [sorting, setSorting] = useState<SortingState>([]);
  const justRefreshedRef = useRef(false);
  const pendingHighlightRef = useRef<UpdatedFieldsMap | null>(null);
  const searchInputTimeoutRef = useRef<any>(null);
  const [open, setOpen] = useState(false);
  const [isDiagramView, setIsDiagramView] = useState(false);
  const diagramRef = useRef<go.Diagram | null>(null);


  useEffect(() => {
    setTotalPages(Math.ceil(totalCount / pageSize));
    setCurrentPage(1);
  }, [pageSize, totalCount]);

  useEffect(() => {
    const fetchLatestAlarmData = async () => {
      const response = await getLatestAlarms();
      if (!response)
        console.log("Network response was not ok");

      if (response && response.data) {
        setLatestAlarms(response.data.alarms);
        setTotalAlarms(response.data.totalAlarms);
      }
    };

    fetchLatestAlarmData();
  }, []);

  // Handle incoming SignalR updates for devices top level data
  const handleUpdate = useCallback((msg: string) => {
    const rawDevices: DeviceUpdateMessage[] = JSON.parse(msg);
    console.log("WebSocket update received", rawDevices);

    const isDefaultSorting =
      sorting.length === 0;
    const isSortingOnStatusConnectivityOrLastUpdated =
      sorting.some((s: any) => s.id === "status" || s.id === "connectivity" || s.id === "lastUpdated");

    setDeviceData((prevDevices) => {
      let updatedMacIds: string[] = [];
      let updatedMap: { [macId: string]: string[] } = {};
      let hasChange = false;

      const updatedDevices = prevDevices.map((existingDevice) => {
        const incoming = rawDevices.find((d: any) => d.MacId === existingDevice.macId);
        if (!incoming) return existingDevice;

        const changedFields: string[] = [];
        const updatedDevice = { ...existingDevice };

        if ("Status" in incoming && incoming.Status !== existingDevice.status) {
          updatedDevice.status = incoming.Status!;
          changedFields.push("status");
        }

        if ("Connectivity" in incoming && incoming.Connectivity !== existingDevice.connectivity) {
          updatedDevice.connectivity = incoming.Connectivity!;
          changedFields.push("connectivity");
        }


        if ("LastUpdated" in incoming) {
          updatedDevice.lastUpdated = incoming.LastUpdated!;
        }

        if (changedFields.length > 0) {
          hasChange = true;
          changedFields.push("lastUpdated");
          updatedMacIds.push(existingDevice.macId);
          updatedMap[existingDevice.macId] = changedFields;
          return updatedDevice;
        }

        return existingDevice;
      });

      if (hasChange) {
        console.log("Devices updated:", updatedMacIds);
        // If not on page 1, skip highlight and reordering(commenting this code as of now as suggested changes in demo)
        // if (currentPage !== 1) {
        //   setRefreshDeviceDataKey(prev => prev + 1);
        //   justRefreshedRef.current = true;
        //   return prevDevices;
        // }

        updateState((draft) => {
          // 1ï¸âƒ£ Update only affected devices
          draft.devices.forEach((device) => {
            if (!updatedMacIds.includes(device.macId)) return;

            const changes = updatedMap[device.macId];
            const updatedDevice = updatedDevices.find((d) => d.macId === device.macId);
            if (!updatedDevice) return;

            if (changes.includes("status")) device.status = updatedDevice.status;
            if (changes.includes("connectivity")) device.connectivity = updatedDevice.connectivity;
            if (changes.includes("lastUpdated")) device.lastUpdated = updatedDevice.lastUpdated;
          });


        });
        if (justRefreshedRef.current) {
          setTimeout(() => {
            setUpdatedFieldsMap(updatedMap);
            highlightTimeoutRef.current = setTimeout(() => setUpdatedFieldsMap(null), 3000);
            justRefreshedRef.current = false;
          }, 100);
        } else {
          setUpdatedFieldsMap(updatedMap);
          if (highlightTimeoutRef.current) clearTimeout(highlightTimeoutRef.current);
          highlightTimeoutRef.current = setTimeout(() => setUpdatedFieldsMap(null), 3000);
        }

        if (isDefaultSorting) {
          const updatedSet = new Set(updatedMacIds);
          const updatedRows = updatedDevices.filter((d) => updatedSet.has(d.macId));
          const restRows = updatedDevices.filter((d) => !updatedSet.has(d.macId));
          return [...updatedRows, ...restRows];
        }

        if (isSortingOnStatusConnectivityOrLastUpdated) {
          pendingHighlightRef.current = updatedMap;
          setRefreshDeviceDataKey(prev => prev + 1);
          justRefreshedRef.current = true;
        }

        return updatedDevices;
      }

      if (currentPage !== 1) {
        setRefreshDeviceDataKey(prev => prev + 1);
        justRefreshedRef.current = true;
        return prevDevices;
      }

      // Handle unseen updates (on page 1 with matching MacId not visible)
      const incomingMacs = new Set(rawDevices.map((d: any) => d.MacId));
      const currentMacs = new Set(prevDevices.map((d) => d.macId));
      const unseenUpdates = [...incomingMacs].filter(mac => !currentMacs.has(mac));

      if (unseenUpdates.length > 0 && currentPage === 1 && (searchInput === "" || searchInput == null)) {
        const unseenMap: { [macId: string]: string[] } = {};
        rawDevices.forEach((d: any) => {
          if (!currentMacs.has(d.MacId)) {
            const fields: string[] = [];
            if ("Status" in d) fields.push("status");
            if ("Connectivity" in d) fields.push("connectivity");
            if ("Connectivity" in d || "Status" in d) fields.push("lastUpdated");
            unseenMap[d.MacId] = fields;
          }
        });

        pendingHighlightRef.current = unseenMap;
        setRefreshDeviceDataKey(prev => prev + 1);
        justRefreshedRef.current = true;
      }

      return prevDevices;
    });

  }, [sorting, currentPage, searchInput]);

  useEffect(() => {
    return () => {
      if (highlightTimeoutRef.current) {
        clearTimeout(highlightTimeoutRef.current);
      }
    };
  }, []);

  const handleAlertUpdates = useCallback((msg: string) => {
    const incomingUpdates: AlarmResponse = JSON.parse(msg);

    setLatestAlarms(incomingUpdates.alarms);
    setTotalAlarms(incomingUpdates.totalAlarms);
  }, []);

  // SignalR connection for devices top level data
  useDevicesTopDataSocket(handleUpdate);

  //signalR for alarms data
  useDeviceAlertSocket("sampleDeviceId", handleAlertUpdates, "ReceiveMainPageUpdates");

  // Initial data fetch
  useEffect(() => {
    // const fetchDevicesFileNames = async () => {
    //   const response = await getMacIdToFileNameMap();
    //   if (!response)
    //     console.log("Network response was not ok");

    //   if (response && response.data) {
    //     setDeviceFileNames(response.data);
    //   }
    // };

    const fetchDevicesData = async () => {
      const response = await getDevicesNameMacIdList();
      if (!response)
        console.log("Network response was not ok");

      if (response && response.data) {
        setDevicesNameMacList(response.data);
      }
    };

    fetchDevicesData();
    // fetchDevicesFileNames();
  }, [hardRefreshDeviceDataKey]);

  useEffect(() => {
    if (pendingHighlightRef.current && deviceData.length > 0) {
      const pendingMap = pendingHighlightRef.current;
      const macIdsInData = new Set(deviceData.map(d => d.macId));

      const validPendingMap: { [macId: string]: string[] } = {};
      Object.entries(pendingMap).forEach(([macId, fields]) => {
        if (macIdsInData.has(macId)) {
          validPendingMap[macId] = fields;
        }
      });

      if (Object.keys(validPendingMap).length > 0) {
        setUpdatedFieldsMap(validPendingMap);

        if (highlightTimeoutRef.current) {
          clearTimeout(highlightTimeoutRef.current);
        }

        highlightTimeoutRef.current = setTimeout(() => {
          setUpdatedFieldsMap(null);
        }, 3000);
      }

      pendingHighlightRef.current = null;
    }
  }, [deviceData]);


  useEffect(() => {
    if (searchInput == "" || searchInput == null) {
      const fetchDevicesData = async () => {
        const response = await getDeviceMetadataPaginatedandSorted(currentPage, pageSize, sorting);
        if (!response)
          console.log("Network response was not ok");

        if (response && response.data) {
          setDeviceData(response.data.data);
          setTotalCount(response.data.totalCount);
        }
      };

      fetchDevicesData();
    }
  }, [pageSize, currentPage, refreshDeviceDataKey, sorting, searchInput]);

  useEffect(() => {
    if (searchInput == "" || searchInput == null) {
      return;
    }
    else if (searchInput != null) {
      const fetchSearchedDevicesData = async () => {
        const response = await getSearchedDeviceMetadataPaginated(currentPage, pageSize, searchInput, sorting);
        if (!response)
          console.log("Network response was not ok");

        if (response && response.data) {
          setDeviceData(response.data.data);
          setTotalCount(response.data.totalCount);
        }
      }
      fetchSearchedDevicesData();
    }
  }, [searchInput, sorting, pageSize, currentPage, refreshDeviceDataKey]);

  const changeSearchInput = (value: string) => {
    if (value == null || value == "")
      setSearchInput("");
    if (searchInputTimeoutRef.current)
      clearTimeout(searchInputTimeoutRef.current);

    searchInputTimeoutRef.current = setTimeout(() => {
      setSearchInput(value);
    }, 1000);
  }

  const openPropertypanel = (deviceId: string) => {
    setActiveTab(initialTabState); // Reset to default tab
    setIsPropertyPanelOpen(true);
    // setCurrentDeviceFileName(deviceFileNames[deviceId] || null);
    setCurrentDeviceId(deviceId);

  }

  const closePropertyPanel = () => {
    setIsPropertyPanelOpen(false);
    setCurrentDeviceId(null);
    setSelectedDevicePropertyPanel(null);
    // setCurrentDeviceFileName(null);

    diagramRef.current?.clearSelection();
  }

  const getRefreshedData = async () => {
    const response = await getAllDataRefereshedFromCache(currentPage, pageSize, sorting, searchInput);
    if (!response)
      console.log("Network response was not ok");

    if (response && response.data) {
      setDeviceData(response.data.data);
      setTotalCount(response.data.totalCount);
      setHardRefreshDeviceDataKey(prev => prev + 1); // Trigger hard refresh when data refreshed in backend cache
    }
  };

  function createDiagram(diagram: go.Diagram) {
    const $ = go.GraphObject.make;

    // Basic setup
    diagram.initialContentAlignment = go.Spot.Center;
    diagram.autoScale = go.Diagram.Uniform;
    diagram.contentAlignment = go.Spot.Center;
    diagram.layout = $(go.TreeLayout, {
      angle: 90,
      layerSpacing: 80,
      alignment: go.TreeLayout.AlignmentCenterChildren,
    });

    diagram.toolManager.hoverDelay = 200;

    /* --------------------------- Group Template --------------------------- */
    diagram.groupTemplate = $(
      go.Group,
      "Auto",
      {
        layout: $(go.GridLayout, {
          wrappingColumn: 4,
          cellSize: new go.Size(130, 100),
          spacing: new go.Size(30, 30),
          alignment: go.GridLayout.Position,
        }),
        background: "transparent",
      },
      // Outer rounded rectangle background
      $(
        go.Shape,
        "RoundedRectangle",
        {
          fill: "#f9fafb",
          stroke: "#cbd5e1",
          strokeWidth: 2,
        }
      ),
      // Main vertical stack panel (Title + Placeholder)
      $(
        go.Panel,
        "Vertical",
        { margin: 10 },
        // ðŸ·ï¸ Group Title
        $(
          go.TextBlock,
          {
            font: "bold 14px Inter, sans-serif",
            stroke: "#334155",
            margin: new go.Margin(5, 0, 10, 0),
            alignment: go.Spot.Center,
            editable: false,
          },
          new go.Binding("text")
        ),
        // Child Nodes Placeholder
        $(go.Placeholder, { padding: 20 })
      )
    );

    /* --------------------------- Server Node --------------------------- */
    diagram.nodeTemplateMap.add(
      "server",
      $(
        go.Node,
        "Auto",
        {
          isShadowed: true,
          shadowBlur: 10,
          shadowColor: "rgba(0,0,0,0.15)"
        },
        $(go.Shape, "RoundedRectangle", {
          fill: "#e2e8f0",
          stroke: "#334155",
          strokeWidth: 2,
        }),
        $(go.TextBlock, {
          margin: 10,
          font: "bold 14px Inter, sans-serif",
          stroke: "#1e293b",
        }, new go.Binding("text", "text"))
      )
    );

    /* --------------------------- Device Node --------------------------- */
    function makeKV(label: string, field: string) {
      return $(
        go.Panel,
        "Horizontal",
        { margin: new go.Margin(2, 0, 0, 0) },
        $(go.TextBlock, label, {
          font: "11px Inter, sans-serif",
          stroke: "#475569",
          margin: new go.Margin(0, 4, 0, 0),
        }),
        $(go.TextBlock, {
          font: "11px Inter, sans-serif",
          stroke: "#334155",
          wrap: go.TextBlock.None,
        }, new go.Binding("text", field))
      );
    }

    diagram.nodeTemplate = $(
      go.Node,
      "Spot",
      { margin: 6, width: 100, height: 88, cursor: "pointer" },
      $(
        go.Panel,
        "Vertical",
        $(go.Shape, "RoundedRectangle",
          {
            fill: "white",
            strokeWidth: 2,
            desiredSize: new go.Size(80, 52),
          },
          new go.Binding("stroke", "status", (s) =>
            s === "Online" ? "#16a34a" : "#dc2626"
          ),
        ),
        $(go.TextBlock, { font: "18px sans-serif", stroke: "#475569" },
          new go.Binding("text", "icon")),
        $(go.TextBlock, {
          font: "11px Inter, sans-serif",
          stroke: "#1e293b",
          margin: 2,
        }, new go.Binding("text", "text"))
      ),

      // Status LED
      $(go.Shape, "Circle", {
        alignment: go.Spot.TopRight,
        alignmentFocus: go.Spot.TopRight,
        desiredSize: new go.Size(12, 12),
        stroke: "#f1f5f9",
        strokeWidth: 1.5,
      }, new go.Binding("fill", "status", (s) =>
        s === "Online" ? "#22c55e" : "#ef4444"
      )),

      // Tooltip
      {
        toolTip: $(
          go.Adornment,
          "Auto",
          $(go.Shape, { fill: "#f9fafb", stroke: "#cbd5e1", strokeWidth: 1 }),
          $(
            go.Panel,
            "Vertical",
            { padding: 8, defaultAlignment: go.Spot.Left },
            $(go.TextBlock, "Device Info", {
              margin: new go.Margin(0, 0, 6, 0),
              font: "bold 12px Inter, sans-serif",
              stroke: "#1e293b",
            }),
            makeKV("Type:", "type"),
            makeKV("MAC:", "macId"),
            makeKV("Connectivity:", "connectivity"),
            makeKV("Last Updated:", "lastUpdated")
          )
        ),
      }
    );

    /* --------------------------- Link Template --------------------------- */
    diagram.linkTemplate = $(
      go.Link,
      { routing: go.Link.AvoidsNodes, curve: go.Link.JumpGap, corner: 5 },
      $(go.Shape, { strokeWidth: 2, stroke: "#475569" }),
      $(go.Shape, { toArrow: "Standard", fill: "#475569" })
    );

    diagramRef.current = diagram;
  }

  const handleModelChange = useCallback((e: any) => {
    // console.log(e);
  }, []);
  
  useEffect(() => {
    const fetchAllDeviceData = async () => {
      const response = await getDeviceMetadata();
      if (!response)
        console.log("Network response was not ok");

      if (response && response.data) {
        updateState(draft => {
          draft.devices = response.data.data;
        });
      }
    };

    fetchAllDeviceData();
  }, []);

  const diagramData = useMemo(() => {
    const nodes: go.ObjectData[] = [
      { key: 0, text: "Monitoring Server", category: "server" },
      { key: 1, text: "Devices", isGroup: true },
      ...state.devices.map((d, i) => ({
        key: d.macId,
        text: d.name,
        status: d.status,
        connectivity: d.connectivity,
        type: d.type,
        macId: d.macId,
        lastUpdated: formatDateTime(d.lastUpdated),
        icon: getIcon(d.type),
        parent: 1,
      })),
    ];
    const links: go.ObjectData[] = [{ from: 0, to: 1 }];
    return { nodes, links };
  }, [state.devices]);

  useEffect(() => {
    console.log(diagramData);

    updateState((draft) => {
      draft.nodeDataArray = diagramData.nodes;
      draft.linkDataArray = diagramData.links;
    });
  }, [diagramData, updateState]);

  const setDeviceView = () => {
    setIsDiagramView(!isDiagramView);
  };

  const downloadDiagram = () => {
    if (diagramRef && diagramRef.current) {
      const diagram = diagramRef.current;
      diagram.commandHandler.downloadSvg({ name: "mySVGfile.svg" });  
    }else{
      alert('Diagram download failed!');
    }
  }

  return (
    <div className={styles.homeContainer}>
      <div className={styles.upperNav}>
        <div onMouseEnter={() => setIsAlarmPopOverOpen(true)} onMouseLeave={() => setIsAlarmPopOverOpen(false)}>
          <PopOver isOpen={isAlarmPopOverOpen}
            triggerContent={
              <div className={styles.alarmIconContainer}>
                <BellRing cursor="pointer" size={25} fill="#fbc02d"
                  onClick={(event: any) => {
                    event.stopPropagation();
                    setIsAlarmPanelOpen((prev) => !prev);
                  }}
                />
                <div className={styles.badgeConainer}>
                  <Badge label={totalAlarms.toString()} bgColor="darkgray" textColor="light" />
                </div>
              </div>
            }
          >
            {(latestAlarms && latestAlarms.length > 0) && (<AlarmPopUp latestAlarms={latestAlarms} totalAlarms={totalAlarms} setIsAlarmPanelOpen={setIsAlarmPanelOpen} />)}
          </PopOver>
        </div>
        <div onMouseEnter={() => setIsProfilePopOverOpen(true)} onMouseLeave={() => setIsProfilePopOverOpen(false)}>
          <PopOver isOpen={isProfilePopOverOpen}
            triggerContent={
              <div className={styles.alarmIconContainer}>
                <UserPen cursor="pointer" size={25} fill="#000" />
              </div>
            }
          >
            <ProfilePopUp />
          </PopOver>
        </div>
      </div>

      <div className={`${styles.subContainer} m-3`}>
        <Sidebar zIndex="zIndex300" openIconMsg={"Open Alarm Panel"} closeIconMsg={"Close Alarm Panel"} position="left" isOpen={isAlarmPanelOpen} setIsOpen={setIsAlarmPanelOpen} >
          {isAlarmPanelOpen && <AlarmPanel devicesNameMacList={devicesNameMacList} setSelectedDevicePropertyPanel={setSelectedDevicePropertyPanel} selectedDevicePropertyPanel={selectedDevicePropertyPanel} />}
        </Sidebar>

        <div>
          <span className={`py-3 ${styles.mainPageTitle}`}>Welcome back, Premal Kadam</span>
          <div className={`py-2 pr-4 ${styles.subNav}`}>
            <input onChange={(event: any) => { changeSearchInput(event.target.value) }} className={styles.mainPageSearchInput} type="search" placeholder="Search..." />
            <div className={styles.mainPageIcons}>
              {isDiagramView &&
              <Tooltip openDelay={100} closeDelay={150} content={<span className="p-2">Download diagram</span>}>
                  <Download className={styles.deviceRefreshIcon} onClick={() => { downloadDiagram() }} strokeWidth={"2.5px"} size={25} cursor={"pointer"} />
                </Tooltip>}
              {(sorting && sorting.length > 0) &&
                <Tooltip openDelay={100} closeDelay={150} content={<span className="p-2">Clear sorting</span>}>
                  <ListX className={styles.deviceRefreshIcon} onClick={() => { setSorting([]) }} strokeWidth={"2.5px"} size={25} cursor={"pointer"} />
                </Tooltip>}
              {deviceData && deviceData.length > 0 &&
                <Tooltip openDelay={100} closeDelay={150} content={<span className="p-2">Refresh Device Cache</span>}>
                  <Repeat className={styles.deviceRefreshIcon} onClick={() => { getRefreshedData(); justRefreshedRef.current = true; }} strokeWidth={"2.5px"} size={25} cursor={"pointer"} />
                </Tooltip>}
              <div>
                <Settings isDiagramView = {isDiagramView} setDeviceView = {setDeviceView} setHardRefreshDeviceDataKey={setHardRefreshDeviceDataKey} setRefreshDeviceDataKey={setRefreshDeviceDataKey}/>
              </div>
            </div>
          </div>
        </div>

        <div className={styles.bodyContainer}>
          <div className={`${styles.pageWrapper} ${isPropertyPanelOpen ? styles.pushRight : ''}`}>
            {!isDiagramView ?
              <TableComponent currentDeviceId={currentDeviceId} sorting={sorting} setSorting={setSorting} refreshDeviceDataKey={refreshDeviceDataKey} updatedFieldsMap={updatedFieldsMap} totalPages={totalPages} pageSize={pageSize} setPageSize={setPageSize} setCurrentPage={setCurrentPage} currentPage={currentPage} data={deviceData} setIsPropertyPanelOpen={openPropertypanel} />
              :
              <ReactDiagramWrapper
                nodeDataArray={state.nodeDataArray}
                linkDataArray={state.linkDataArray}
                modelData={state.modelData}
                skipsDiagramUpdate={state.skipsDiagramUpdate}
                onModelChange={handleModelChange}
                onInitDiagram={createDiagram}
                onDiagramEvent={(e: go.DiagramEvent) => {
                  const name = e.name;
                  console.log(name);
                  
                  switch (name) {
                    case 'ChangedSelection': {
                      const sel = e.subject.first();
                      console.log(sel);

                      if (sel instanceof go.Node) {
                        const data = sel.data;

                        // Example conditions â€” adjust based on your model
                        if (data?.macId) {
                          console.log('Device node selected:', data);
                          openPropertypanel(data.macId);
                        } else {
                          closePropertyPanel();
                        }
                      } else {
                        closePropertyPanel();
                      }
                      break;
                    }
                    case 'ClipboardPasted': {
                      console.log(e.subject);
                      
                      break;
                    }
                    default:
                      break;
                  }
                }}

              />
            }
          </div>
          {(deviceData && deviceData.length > 0) &&
            <Sidebar zIndex="zIndex200" openIconMsg={"Open Property Panel"} closeIconMsg={"Close Property Panel"} position="right" isOpen={isPropertyPanelOpen} setIsOpen={setIsPropertyPanelOpen} closeSidebar={closePropertyPanel}>
              {isPropertyPanelOpen && <PropertyPanel devicesNameMacList={devicesNameMacList} setCurrentDeviceId={setCurrentDeviceId} setIsAlarmPanelOpen={setIsAlarmPanelOpen} setSelectedDevicePropertyPanel={setSelectedDevicePropertyPanel} activeTab={activeTab} setActiveTab={setActiveTab} currentDeviceId={currentDeviceId} />}
            </Sidebar>}
        </div>
      </div>
    </div>
  );
};
```

## pages/_app.tsx

```text
import { Provider } from "@/components/ui/provider";
import "@/styles/globals.css";
import type { AppProps } from "next/app";
import "@/styles/scss/utilities.scss";
import 'rsuite/dist/rsuite-no-reset.min.css';
import { CustomProvider } from 'rsuite';

export default function App({ Component, pageProps }: AppProps) {
  return (
    <CustomProvider>
      <Provider>
        <Component {...pageProps} />
      </Provider>
    </CustomProvider>
  );
}
```

## pages/_document.tsx

```text
import { Html, Head, Main, NextScript } from "next/document";

export default function Document() {
  return (
    <Html lang="en">
      <Head />
      <body>
        <Main />
        <NextScript />
      </body>
    </Html>
  );
}
```

## services/alarmservice.ts

```typescript
import { handleAxiosError } from "@/utils/helperfunctions";
import { alarmServiceBaseURL } from "@/utils/helpervariables";
import axios, { AxiosResponseHeaders, InternalAxiosRequestConfig } from "axios";
import { graphqlRequest } from "./graphqlClient";

//Rest version
// export const getAlarmPanelData = async (alarmsFilters: any) => {  
//   try {    
//     const response = await axios.post(`${alarmServiceBaseURL}/api/Alarms/getAlarms`, alarmsFilters);
//     return response;
//   } catch (error : any) {
//      handleAxiosError(error);
//   }
// };

//GraphQL version
const buildAlarmFilter = (filters: any) => {
  return {
    devices: Array.isArray(filters?.devices) ? filters.devices : [],
    filterDateRange: Array.isArray(filters?.filterDateRange)
      ? filters.filterDateRange
      : [],
  };
};

export const getAlarmPanelData = async (
  alarmsFilters: any
) => {
  const query = `
    query ($filter: AlarmFilter!) {
      alarms(filter: $filter) {
        id
        sourceDeviceMacId
        severity
        message
        raisedAt
        alarmState
        acknowledgedFrom
        isAcknowledged
        acknowledgedAt
        alarmComment
      }
    }
  `;

  const filter = buildAlarmFilter(alarmsFilters);

  const data = await graphqlRequest<{ alarms: any[] }>(query, {
    filter,
  });
  
  const response = {
    data: data.alarms,
  }
  return response;
};

//Rest version

// export const getLatestAlarms = async () => {
//   try {
//     const response = await axios.get(`${alarmServiceBaseURL}/api/Alarms/getLatestAlarms`);
//     return response;
//   } catch (error : any) {
//      handleAxiosError(error);
//   }
// };

//GraphQL version
export const getLatestAlarms = async () => {
  const query = `
    query {
      latestAlarms {
        totalAlarms
        alarms {
          id
          sourceDeviceMacId
          severity
          message
          raisedAt
          alarmState
          acknowledgedFrom
          isAcknowledged
          acknowledgedAt
          alarmComment
        }
      }
    }
  `;

  const data = await graphqlRequest<{ latestAlarms: any }>(query);
  
  const response = {
    data: data.latestAlarms,
  }
  return response;
};

//Rest version 
// export const getLatestAlarmForDevice = async (deviceMacId : any) => {
//   try {
//     const response = await axios.get(`${alarmServiceBaseURL}/api/Alarms/getLatestAlarmForDevice/${deviceMacId}`);
//     return response;
//   } catch (error : any) {
//      handleAxiosError(error);
//   }
// };

//GRaphQL version
export const getLatestAlarmForDevice = async (deviceMacId: any) => {
  const query = `
    query ($deviceMacId: String!) {
      latestAlarmForDevice(deviceMacId: $deviceMacId) {
        totalAlarms
        alarm {
          id
          sourceDeviceMacId
          severity
          message
          raisedAt
          alarmState
          acknowledgedFrom
          isAcknowledged
          acknowledgedAt
          alarmComment
        }
      }
    }
  `;

  const data = await graphqlRequest<{ latestAlarmForDevice: any }>(query, {
    deviceMacId,
  });

  const response = {
    data: data.latestAlarmForDevice,
  }
  return response;
};

//Rest version
// export const investigateAlarm = async (alarmId: any) => {
//   try {
//     const response = await axios.put(`${alarmServiceBaseURL}/api/Alarms/investigateAlarm/${alarmId}`);
//     return response;
//   } catch (error : any) {
//      handleAxiosError(error);
//   }
// };

//GraphQL version
export const investigateAlarm = async (alarmId: any) => {
  const mutation = `
    mutation ($id: UUID!) {
      investigateAlarm(id: $id) {
        id
        sourceDeviceMacId
        alarmState
        isAcknowledged
        acknowledgedFrom
        acknowledgedAt
        severity
        message
        raisedAt
        alarmComment
      }
    }
  `;

  const data = await graphqlRequest<{ investigateAlarm: any }>(mutation, {
    id: alarmId,
  });

  const response = {
    data: data.investigateAlarm,
  }
  return response;
};

//Rest version
// export const resolveAlarm = async (alarmId: any, input : string) => {
//   const value = (input && input.length > 0) ? input :  "manual";
//   try {
//     const response = await axios.put(`${alarmServiceBaseURL}/api/Alarms/resolveAlarm/${alarmId}/${value}`);
//     return response;
//   } catch (error : any) {
//      handleAxiosError(error);
//   }
// };

//GraphQL version
export const resolveAlarm = async (alarmId: any, input: string) => {
  const comment = input && input.length > 0 ? input : "manual";

  const mutation = `
    mutation ($id: UUID!, $comment: String!) {
      resolveAlarm(id: $id, comment: $comment) {
        id
        sourceDeviceMacId
        alarmState
        isAcknowledged
        acknowledgedFrom
        acknowledgedAt
        severity
        message
        raisedAt
        alarmComment
      }
    }
  `;

  const data = await graphqlRequest<{ resolveAlarm: any }>(mutation, {
    id: alarmId,
    comment,
  });

  const response = {
    data: data.resolveAlarm,
  }
  return response;
};

//Rest version
// export const ignoreAlarm = async (alarmId: any, input : string) => {
//   const value = (input && input.length > 0) ? input :  "manual";
//   try {
//     const response = await axios.delete(`${alarmServiceBaseURL}/api/Alarms/ignoreAlarm/${alarmId}/${value}`);
//     return response;
//   } catch (error : any) {
//      handleAxiosError(error);
//   }
// };

//GraphQL version
export const ignoreAlarm = async (alarmId: any, input: string) => {
  const comment = input && input.length > 0 ? input : "manual";

  const mutation = `
    mutation ($id: UUID!, $comment: String!) {
      ignoreAlarm(id: $id, comment: $comment) {
        id
        sourceDeviceMacId
        alarmState
        isAcknowledged
        acknowledgedFrom
        acknowledgedAt
        severity
        message
        raisedAt
        alarmComment
      }
    }
  `;

  const data = await graphqlRequest<{ ignoreAlarm: any }>(mutation, {
    id: alarmId,
    comment,
  });

  const response = {
    data: data.ignoreAlarm,
  }
  return response;
};


//Rest version alarm states
// export const getAlarmStates = async () => {
//   try {
//     const response = await axios.get(`${alarmServiceBaseURL}/api/Alarms/getAlarmStates`);
//     return response;
//   } catch (error : any) {
//      handleAxiosError(error);
//   }
// };

//GraphQL version alarm states
export const getAlarmStates = async () => {
  const query = `
    query {
      alarmStates {
        id
        name
      }
    }
  `;

  const data = await graphqlRequest<{ alarmStates: any[] }>(query);

  const response = {
    data: data.alarmStates,
  }
  return response;
};
```

## services/deviceservice.ts

```typescript
import { handleAxiosError } from "@/utils/helperfunctions";
import { baseURL } from "@/utils/helpervariables";
import axios from "axios";

//get property panel data for a device
export const getPropertyPanelData = async (currentDeviceMacId: any) => {
  try {
    const response = await axios.get(`${baseURL}/api/Devices/getPropertyPanelData/${currentDeviceMacId}`);
    return response;
  } catch (error : any) {
     handleAxiosError(error);
  }
};

export const getSearchedDeviceMetadataPaginated = async (pageNo : any, pageSize : any, input : any, sortingState : any) => {
  try {
    const requestObject = {pageNumber : pageNo, pageSize : pageSize, sorting : sortingState };
    const response = await axios.post(`${baseURL}/api/Devices/search/metadata/${input}`, requestObject);
    return response;
  } catch (error : any) {
     handleAxiosError(error);
  }
};

export const getDeviceMetadataPaginatedandSorted = async (pageNo : any, pageSize : any, sortingState : any) => {
  try {
    const requestObject = {pageNumber : pageNo, pageSize : pageSize, sorting : sortingState };
    const response = await axios.post(`${baseURL}/api/Devices/metadata`,requestObject);
    return response;
  } catch (error : any) {
     handleAxiosError(error);
  }
};

export const getDeviceMetadata = async () => {
  try { 
    const response = await axios.post(`${baseURL}/api/Devices/allMetadata`);
    return response;
  } catch (error : any) {
     handleAxiosError(error);
  }
};

export const getAllDataRefereshedFromCache = async (pageNo : any, pageSize : any, sortingState : any, input : any) => {
  try {
    (input == null || input == undefined || input == "") ? input = "undefined" : input = input;
    const requestObject = {pageNumber : pageNo, pageSize : pageSize, sorting : sortingState };
    const response = await axios.post(`${baseURL}/api/Devices/refreshCache/${input}`,requestObject);
    return response;
  } catch (error : any) {
     handleAxiosError(error);
  }
};

export const uploadFile = async (file : File) => {
  try {
    const formData = new FormData();
    formData.append("file", file);
    const response = await axios.post(`${baseURL}/api/Devices/uploadFile`,formData);
    return response;
  } catch (error : any) {
     return error;
  }
};


export const getDevicesTopLevelData = async (pageNo : any, pageSize : any) => {
  try {
    const response = await axios.get(`${baseURL}/api/Devices/metadata/${pageNo}/${pageSize}`);
    return response;
  } catch (error : any) {
     handleAxiosError(error);
  }
};

export const getDevicesNameMacIdList = async () => {
  try {
    const response = await axios.get(`${baseURL}/api/Devices/getDevicesNameMacIdList`);
    return response;
  } catch (error : any) {
     handleAxiosError(error);
  }
};

export const getMacIdToFileNameMap = async () => {
  try {
    const response = await axios.get(`${baseURL}/api/Devices/getMacIdToFileNameMap`);
    return response;
  } catch (error : any) {
     handleAxiosError(error);
  }
};

export const getAlarmToggleValue = async () => {
  try {
    const response = await axios.get(`${baseURL}/api/Devices/alarmToggle`);
    return response;
  } catch (error : any) {
     handleAxiosError(error);
  }
};

export const setAlarmToggleValue = async (alarmToggle: boolean) => {  
  try {    
    const response = await axios.post(`${baseURL}/api/Devices/alarmToggle/${alarmToggle}`);
    return response;
  } catch (error : any) {
     handleAxiosError(error);
  }
};
```

## services/graphqlClient.ts

```typescript
import axios from "axios";
import { alarmServiceBaseURL } from "@/utils/helpervariables";
import { handleAxiosError } from "@/utils/helperfunctions";

export const graphqlRequest = async <T>(
  query: string,
  variables?: Record<string, any>
): Promise<T> => {
  try {
    const response = await axios.post(
      `${alarmServiceBaseURL}/graphql`,
      {
        query,
        variables,
      },
      {
        headers: {
          "Content-Type": "application/json",
        },
      }
    );

    if (response.data.errors) {
      throw response.data.errors;
    }

    return response.data.data;
  } catch (error: any) {
    handleAxiosError(error);
    throw error;
  }
};
```

## sockets/signalRConnection.ts

```typescript
import { websocketGatewayUrl } from "@/utils/helpervariables";
import * as signalR from "@microsoft/signalr";

let connection: signalR.HubConnection | null = null;

async function startConnection(conn: signalR.HubConnection) {
  try {
    await conn.start();
    console.log("SignalR connected to GatewayHub.");
  } catch (err) {
    console.warn("SignalR connection failed:", err);
    // Retry logic can be added if needed
  }
}

export async function getSignalRConnection(): Promise<signalR.HubConnection> {
  if (!connection) {
    connection = new signalR.HubConnectionBuilder()
      .withUrl(websocketGatewayUrl)
      .withAutomaticReconnect()
      .build();

    await startConnection(connection);
  }

  return connection;
}
```

## styles/globals.css

```css
:root {
  --background: #ffffff;
  --foreground: #171717;
}

/* @media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
} */

html,
body {
  max-width: 100vw;
  overflow-x: hidden;
}

body {
  color: var(--foreground);
  background: var(--background);
  font-family: Arial, Helvetica, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  background-color: #f0f0f0;
}


* {
  box-sizing: border-box;
  padding: 0;
  margin: 0;
}

h1 {
  font-size: 2rem;
  font-weight: 700;
}
h2 {
  font-size: 1.75rem;
  font-weight: 600;
}
h3 {
  font-size: 1.5rem;
}
h4 {
  font-size: 1.25rem;
}
h5 {
  font-size: 1rem;
}
h6 {
  font-size: 0.875rem;
  font-weight: 500;
}

a {
  color: inherit;
  text-decoration: none;
}

@media (prefers-color-scheme: dark) {
  html {
    color-scheme: dark;
  }
}

.rs-picker-popup.rs-picker-popup-daterange {
  z-index: 4000 !important;
}

.rs-input-group.rs-input-group-inside, .rs-input{
  background-color: transparent !important;
}

.rs-input-group{
  border : 1px solid #27272a !important;
}

.rs-input-group:focus-within{
  border-color: #a1a1aa !important;
  outline : none !important;
}

.rs-input{
  padding: 0.5rem 0.5rem !important ;
  color: #000 !important;
}

.rs-input::placeholder{
  color: #252525 !important;
}

.rs-picker-caret-icon{
  color: #000 !important;
}

.rs-input-group-addon{
  padding: 0.5rem 0.5rem !important;
}

/* React Diagram Wrapper styles */
.diagram-component {
  margin: auto;
  width: 100%;
  height: 100%;
  border: solid 1px black;
  background-color: #eeeeee;
  border: 1px solid #ccc;
}
```

## styles/Home.module.css

```css
.page {
  --gray-rgb: 0, 0, 0;
  --gray-alpha-200: rgba(var(--gray-rgb), 0.08);
  --gray-alpha-100: rgba(var(--gray-rgb), 0.05);

  --button-primary-hover: #383838;
  --button-secondary-hover: #f2f2f2;

  display: grid;
  grid-template-rows: 20px 1fr 20px;
  align-items: center;
  justify-items: center;
  min-height: 100svh;
  padding: 80px;
  gap: 64px;
  font-family: var(--font-geist-sans);
}

@media (prefers-color-scheme: dark) {
  .page {
    --gray-rgb: 255, 255, 255;
    --gray-alpha-200: rgba(var(--gray-rgb), 0.145);
    --gray-alpha-100: rgba(var(--gray-rgb), 0.06);

    --button-primary-hover: #ccc;
    --button-secondary-hover: #1a1a1a;
  }
}

.main {
  display: flex;
  flex-direction: column;
  gap: 32px;
  grid-row-start: 2;
}

.main ol {
  font-family: var(--font-geist-mono);
  padding-left: 0;
  margin: 0;
  font-size: 14px;
  line-height: 24px;
  letter-spacing: -0.01em;
  list-style-position: inside;
}

.main li:not(:last-of-type) {
  margin-bottom: 8px;
}

.main code {
  font-family: inherit;
  background: var(--gray-alpha-100);
  padding: 2px 4px;
  border-radius: 4px;
  font-weight: 600;
}

.ctas {
  display: flex;
  gap: 16px;
}

.ctas a {
  appearance: none;
  border-radius: 128px;
  height: 48px;
  padding: 0 20px;
  border: none;
  border: 1px solid transparent;
  transition:
    background 0.2s,
    color 0.2s,
    border-color 0.2s;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 16px;
  line-height: 20px;
  font-weight: 500;
}

a.primary {
  background: var(--foreground);
  color: var(--background);
  gap: 8px;
}

a.secondary {
  border-color: var(--gray-alpha-200);
  min-width: 158px;
}

.footer {
  grid-row-start: 3;
  display: flex;
  gap: 24px;
}

.footer a {
  display: flex;
  align-items: center;
  gap: 8px;
}

.footer img {
  flex-shrink: 0;
}

/* Enable hover only on non-touch devices */
@media (hover: hover) and (pointer: fine) {
  a.primary:hover {
    background: var(--button-primary-hover);
    border-color: transparent;
  }

  a.secondary:hover {
    background: var(--button-secondary-hover);
    border-color: transparent;
  }

  .footer a:hover {
    text-decoration: underline;
    text-underline-offset: 4px;
  }
}

@media (max-width: 600px) {
  .page {
    padding: 32px;
    padding-bottom: 80px;
  }

  .main {
    align-items: center;
  }

  .main ol {
    text-align: center;
  }

  .ctas {
    flex-direction: column;
  }

  .ctas a {
    font-size: 14px;
    height: 40px;
    padding: 0 16px;
  }

  a.secondary {
    min-width: auto;
  }

  .footer {
    flex-wrap: wrap;
    align-items: center;
    justify-content: center;
  }
}

@media (prefers-color-scheme: dark) {
  .logo {
    filter: invert();
  }
}
```

## styles/scss/Accordion.module.scss

```text
.accordion {
  width: 100%;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  flex : 1 1 auto;
}

.header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  cursor: pointer;
  font-weight: 600;
  padding-right: 2px;
}

.tabListHeader{
    padding-right: 7px;
}

.content {
  max-height: 0;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  opacity: 0;
  transition: all 0.3s ease;
  padding-top: 0;
  flex: 1 1 auto;
}

.open {
  max-height: calc(100% - 1.7rem); 
  opacity: 1;
}
```

## styles/scss/AlarmPanel.module.scss

```text
@use './utilities.scss' as *;

// components/AlarmPanel.module.scss
.panel {
    background: #fff;
    border-radius: 8px;
    padding: 0.5rem 0 0 0;
    width: 100%;
    max-width: 500px;
    height: 100dvh;
    font-family: Arial, sans-serif;
    display: flex;
    flex-direction: column;

    .alarmsContainer {
        height: 100vh;
    }

    .header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0 3rem 0 0.7rem;

        h2 {
            font-size: 1.15rem;
            font-weight: bold;
            display: flex;
            align-items: center;
        }

        .count {
            padding: 0 8px;
            margin-left: 8px;
            font-size: 0.9rem;
        }

        .filterBtn {
            padding: 0.4rem 1rem;
            background: #eee;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8rem;
            color: black
        }

        .filterBtn:hover {
            background: #e9e9e9;
        }
    }

    .alarmPanelTitles {
        padding-left: 0.7rem;
        padding-bottom: 0.2rem;
        font-weight: 600;
        font-size: 1rem;
    }

    .filters {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        margin: 1rem 0;
        padding: 0 0.5rem;
    }

    .dateFilters {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        margin: 1rem 0;
        padding: 0 0.5rem;
    }

    .zeroFilters {
        display: none
    }

    .section {
        margin-top: 1rem;
        max-height:  calc(50% - 1rem);
        display: flex;
        flex-direction: column;
        overflow: hidden;

        .sectionCount {
            padding: 0 8px;
            margin-left: 0.3rem;
            font-size: 0.8rem;
        }
    }

    .alarmsAccordionSection {
        max-height: 100%;
        overflow-y: scroll;
        flex: 1;

        // Hide scrollbar by default
        &::-webkit-scrollbar {
            width: 5px;
            background: transparent;
        }

        &::-webkit-scrollbar-thumb {
            background-color: transparent;
            transition: background-color 0.3s;
            border-radius: 25px;
        }

        &::-webkit-scrollbar-track {
            background: transparent;
        }

        // Show thumb on hover
        &:hover::-webkit-scrollbar-thumb {
            background-color: rgba(31, 30, 30, 0.3);
        }

        &::-webkit-scrollbar-thumb:hover {
            background-color: #5e5e5e;
            ; // darker on hover
        }

        &:hover::-webkit-scrollbar-track {
            background-color: #f5f5f5;
        }
    }

    // .alarmsAccordionSectionHeight {
    //     max-height: 250px;
    // }

    // .alarmsAccordionSectionHeightWithSelectedDevices {
    //     max-height: 200px;
    // }

    .alarmCardContainer{
        border-left: 4px solid transparent;
        padding: 0.8rem 0.3rem 0.8rem 0.82rem;
        position: relative;
    }

    .resolvedAlarmCard{
        background-color: #ececec;
    }

    .ackAlarmStateIcon{
        position: absolute;
        top: 3px;
        right: 2px; 
    }

    .ackAlarmStateInvestigateIcon{
        fill: #17a2b8;
    }

    .ackAlarmStateResolveIcon{
        fill: #28a745;
    }

    .ackAlarmStateIgnoreIcon{
        fill: #fbc02d;
    }

    .alarmCard {

        .time {
            display: block;
            font-size: 0.75rem;
            color: #888;
            margin-top: 4px;
        }

        .alarmComment{
            display: block;
            font-size: 0.75rem;
            color: #888;
            margin-top: 2px;
        }

        .message {
            font-size: 0.9rem;
        }

        .rightSide {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            justify-content: end;
        }

        .ackBtn {
            padding: 0.2rem 0.7rem;
            font-size: 0.8rem;
            border: none;
            background: transparent;
            border: 1px solid #141414;
            color: black;
            border-radius: 4px;
            text-align: start;
            cursor: pointer;
        }

        .resolveCommentIcon {
            position: absolute;
            right: 5px;
            top: 2px;
        }

        .resolveCommentIcon:hover {
            color: #3b3b3b;
        }


        .ackBtn:hover {
            background: #ededed;
        }
    }

    .alarmCardDiv {
        display: grid;
        grid-template-columns: 63% 35%;
        gap: 0.5rem;
        align-items: center;
    }

    .alarmCard:hover {
        background-color: #f3f3f3;
    }

    .expanded {
        border-left: 4px solid #0288d1;
        background-color: #f3f3f3;
    }

    .expandedContent {
        max-height: 0;
        opacity: 0;
        overflow: hidden;
        transition: all 0.3s ease;
        padding-top: 0;

        display: flex;
        gap: 0.3rem;
        justify-content: flex-start;
    }

    .show {
        max-height: 100px;
        opacity: 1;
        padding-top: 0.5rem;
    }

    .downContainer{
        overflow: hidden;
        flex : 1;
        display: flex;
        flex-direction: column;
//   min-height: 0;
    }
}

.alarmPopUpAlarmCard {
    padding: 0.3rem 0.5rem;
    display: flex;
    gap: 0.5rem;
    align-items: center;
    border-left: 4px solid transparent;

    .time {
        display: block;
        font-size: 0.75rem;
        color: #888;
        margin-top: 1px;
    }

    .message {
        font-size: 0.9rem;
    }
}

.viewBtn {
    float: right;
    padding: 0.15rem 0.6rem;
    font-size: 0.8rem;
    border: none;
    background: #fff;
    border: 1px solid #141414;
    color: black;
    border-radius: 4px;
    cursor: pointer;
    margin: 0rem 0.7rem 0.8rem 0rem;
}

.viewBtn:hover {
    background: #f2f2f2;
}

.alarmPopOverSection {
    padding: 0.3rem 0.1rem;
}

.severityDot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    flex-shrink: 0;
}

@each $name, $color in $colors {
    .severityDotBg--#{$name} {
        background-color: $color;
    }
}

.selectFilters {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    padding: 0.5rem 0.7rem 0 0.7rem;
    width: 100%;
}

.resolveCommentInput {
    background-color: transparent;
    border-radius: 5px;
    border: 1px solid #c1c1c1;
    color: #e7e7e7;
    padding: 0.2rem 0.5rem;
    width: 100%;
    font-size: 0.85rem;
}

.acknowledgedAlarmsFilter{
    padding: 0.5rem 0.7rem 0 0.7rem;
    width: 100%;
}

.clearAlarmFilterIcon {
    transition: color .2s ease-in;
}

.clearAlarmFilterIcon:hover {
    //  stroke-width: 1.8px;
    color: #464646;
}



//Profile pop up

.profilePopOverSection {
    padding: 0.5rem;
}

.profilePopUpTitle {
    font-weight: bold;
    font-size: 1rem;
}

.profilePopUpSubTitle {
    color: #535353;
    font-size: 0.9rem;
}

.profileActionListLi {
    display: flex;
    gap: 0.5rem;
    align-items: center;
    padding-bottom: 0.5rem;
    cursor: pointer;
}

.logoutBtn {
    padding: 0.2rem 1.5rem;
    font-size: 1rem;
    border: none;
    background: transparent;
    border: 1px solid #141414;
    color: black;
    border-radius: 4px;
    cursor: pointer;
}

.logoutBtn:hover {
    background: #ededed;
}


//Alarm panel custom modal styles
.customModalWrapper {
  position: absolute;
  top: 80%;
  left: 50%;
  transform: translate(-50%, -50%);
  z-index: 1000;
  background-color: #fff;
  color: #1b1b1b;
  border: 1px solid #161616;
  padding: 0.5rem 1rem;
  border-radius: 8px;
  box-shadow:
    rgba(0, 0, 0, 0.3) 0px 19px 38px,
    rgba(0, 0, 0, 0.22) 0px 15px 12px;
  width: 300px;
}

.closeBtn {
  position: absolute;
  top: 6px;
  right: 10px;
  background: transparent;
  border: none;
  color: #181818;
  font-size: 18px;
  cursor: pointer;
}

.modalTitle {
  font-size: 0.9rem;
  margin-bottom: 0.5rem;
  text-align: left;
}

.commentInputWrapper {
  margin-bottom: 0.5rem;
}

.resolveCommentInput {
  width: 100%;
  resize: vertical;
  padding: 0.4rem;
  border-radius: 4px;
  border: 1px solid #191919;
  background-color: #fff;
  color: #171717;
  font-size: 0.85rem;
  outline: none;

  &:focus {
    border-color: #3182ce;
  }
}

.modalFooter {
  display: flex;
  justify-content: flex-end;
  gap: 0.5rem;
}

.cancelBtn {
  padding: 0.2rem 0.6rem;
  background: #444;
  border: none;
  color: #fff;
  border-radius: 4px;
  cursor: pointer;
  font-size: 0.85rem;
}

.saveBtn {
  padding: 0.2rem 0.6rem;
  background: #3182ce;
  border: none;
  color: #fff;
  border-radius: 4px;
  cursor: pointer;
  font-size: 0.85rem;
}
```

## styles/scss/Badge.module.scss

```text
@use './utilities.scss' as *;

.badge {
    font-size: 0.75rem;
    padding: 0.2rem 0.6rem;
    border-radius: 12px;
    font-weight: 600;
    text-transform: uppercase;
    color: #fff;
}

@each $name, $color in $colors {
  .badgebg--#{$name} {
    background-color: $color;
  }

  .badgetext--#{$name} {
    color: $color;
  }
}
```

## styles/scss/FileUploader.module.scss

```text
.fileUpload {
  display: flex;
  gap: 0.5rem;
  font-family: sans-serif;
  align-items: left;
}

.fileInput {
  display: none;
}

.uploadButton {
  background-color: #1e1e1e;
  color: #fff;
  padding: 0.3rem 0.8rem;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 0.8rem;

  &:hover {
    background-color: #000000;
  }
}

.fileInfo {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  font-size: 0.9rem;
  color: #333;
}

.fileName {
  flex-grow: 1;
}

.clearIcon {
  cursor: pointer;
  color: #888;

  &:hover {
    color: rgb(0, 0, 0);
  }
}

.submitButton {
  background-color: #2dae31;
  color: white;
  border: none;
  padding: 0.3rem 0.8rem;
  border-radius: 4px;
  font-size: 0.8rem;
  cursor: pointer;
  margin-left: auto;

  &:hover {
    background-color: #388e3c;
  }
}

.noFile {
  font-size: 14px;
  color: #999;
  display: flex;
  align-items: center;
}

.infoIcon{
  cursor: pointer;
  margin-left: 0.3rem;
}

.infoIcon:hover {
  color: #555;
}

.error {
  color: red;
  font-size: 13px;
}
```

## styles/scss/global.scss

```text

```

## styles/scss/Home.module.scss

```text
.homePageNav {
    display: flex;
    justify-content: end;
    align-items: center;
    background-color: red;
}

.homeContainer {
    display: flex;
    flex-direction: column;
    background-color: #f5f5f5;
    height: 100vh;
    box-sizing: border-box;
}

.subContainer{
    display: flex;
    flex: 1 1 auto;
    flex-direction: column;
    // overflow: hidden;
}

.bodyContainer {
    // flex: 1 1 auto;
    display: flex;
    position: relative;
    height: calc(100vh - 122.781px);
}

.pageWrapper {
    transition: margin-right 0.3s ease;
    flex: 1 1 auto;
    min-width: 0;

    &.pushLeft {
        margin-left: 330px; // match sidebar width
    }

    &.pushRight {
        margin-right: 355px; // for right sidebar
    }
}

.alarmIconContainer {
    position: relative;

    .badgeConainer {
        position: absolute;
        top: -15px;
        right: -25px;
    }
}

.mainPageTitle {
    font-size: 1.5rem;
}

.mainPageSearchInput {
    width: 260px;
    border: 1px solid #555;
    border-radius: 10px;
    padding: 0.4rem 1.2rem;
    background-color: transparent;
    position: relative;
}

.subNav {
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.upperNav {
    background-color: #fff;
    border-bottom-left-radius: 10px;
    border-bottom-right-radius: 10px;
    display: flex;
    gap: 3rem;
    padding: 1rem 1rem 0.3rem 1rem;
    width: max-content;
    position: fixed;
    top: 0;
    right: 1rem;
    z-index: 100;
    box-shadow: rgba(17, 17, 26, 0.1) 0px 4px 16px, rgba(17, 17, 26, 0.05) 0px 8px 32px;
    border: 1px solid #d3cece;
}

.deviceRefreshIcon {
    transition: color .2s ease-in;
}

.deviceRefreshIcon:hover {
    //  stroke-width: 1.8px;
    color: #464646;
}

.mainPageIcons{
    display: flex;
    gap: 1rem;
    align-items: center;
}
```

## styles/scss/Pagination.module.scss

```text
.paginationContainer {
    display: flex;
    align-items: center;
    justify-content: start;
    padding: 1rem;
    width: 100%;
    overflow-x: auto;
}

.middleSection{
  display: flex;
  gap: 0.5rem;
  align-items: center;
}

.rightSection{
    font-size: 0.9rem;
    color: #666;
    margin-left: 1rem;
}

.paginationButton{
  padding: 0.5rem 0.75rem;
  border: 1px solid #ccc;
  border-radius: 6px;
  background-color: #fff;
  color: #000;
  cursor: pointer;
  min-width: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.activeButton{
    background-color: #222;
    color: #fff;
}

.pageSizeSelector{
    padding: 0.5rem;
    border-radius: 6px;
    border: 1px solid #ccc;
    background-color: #222;
    font-size: 0.9rem;
    appearance: none;
    color: #fff;
    appearance: none;
  padding-right: 2rem;
}


.selectWrapper {
  position: relative;
  display: inline-block;
}

.selectIcon {
  position: absolute;
  right: 0.5rem;
  top: 50%;
  pointer-events: none;
  transform: translateY(-50%);
  color: #fff;
}
```

## styles/scss/PropertyPanel.module.scss

```text
.propertyPanelContainer{
    height: calc(100vh - 122.781px);
}

.propertyPanelMainContent{
    height: calc(100% - 59.6px);
    display: flex;
    flex-direction: column;
}

.propertyPanelTabContent {
    // max-height: 500px;
    flex : 1 1 auto;
    overflow-y: auto;

    &:global(body)>& {
        height: 100vh;
    }

    // Hide scrollbar by default
    &::-webkit-scrollbar {
        width: 3px;
        background: transparent;
    }

    &::-webkit-scrollbar-thumb {
        background-color: transparent;
        transition: background-color 0.3s;
        border-radius: 25px;
    }

    &::-webkit-scrollbar-track {
        background: transparent;
    }

    // Show thumb on hover
    &:hover::-webkit-scrollbar-thumb {
        background-color: rgba(31, 30, 30, 0.3);
    }

    &::-webkit-scrollbar-thumb:hover {
        background-color: #5e5e5e;
        ; // darker on hover
    }

    &:hover::-webkit-scrollbar-track {
        background-color: #f5f5f5;
    }
}

.propertyPanelTitles {
    font-size: 0.9rem;
}

.propertyPanelHeadingContainer{
    display: flex;
    flex-direction: column;

    .deviceSubTitle{
        color: #444444;
        font-size: 0.9rem;
    }

    .deviceTitle{
        font-size: 1.25rem;
    }
}

@for $i from 1 through 10 {
    .depth-#{$i} {
        margin-left: #{0.5 * $i}rem;
    }
}

//sub data property panel
.keyValueSection {
    display: flex;
    flex-direction: column;
    gap: 0.35rem;
}

.kvRow {
    display: grid;
    grid-template-columns: 50% 50%; // Key column fixed, value fills rest
    align-items: start;
    gap: 1rem;
    transition: background-color 0.6s ease-in-out;
}

.kvKey {
    font-weight: 500;
    font-size: 12px;
}

.kvValue {
    font-size: 12px;
    width: 90%;
}


//Tablist component
.tabListUL {
    list-style-type: none;
    display: flex;
    gap: 1.5rem;
    font-size: 14px;
    padding-right: 5px;
    padding-left: 0.5rem;
}

.tabListLi {
    cursor: pointer;
    padding: 4px 0;
    border-bottom: 2px solid transparent;
    font-weight: normal;
    color: #333;
}

.tabListLiActive {
    border-bottom: 2px solid #007bff;
    font-weight: 600;
    color: black
}



//alarm card in health tab
.alarmCard {
    padding: 0.5rem 0.5rem;
    align-items: center;
    background-color: #fff;

    .time {
        display: block;
        font-size: 0.75rem;
        color: #888;
        margin-top: 2px;
    }

    .message {
        font-size: 0.9rem;
    }

    .viewBtn {
        margin-top: 0.3rem;
        padding: 0.2rem 0.6rem;
        font-size: 0.8rem;
        border: none;
        background: transparent;
        border: 1px solid #141414;
        color: black;
        border-radius: 4px;
        cursor: pointer;
    }

    .viewBtn:hover {
        background: #ededed;
    }
}

.highlight {
//   background-color: #f3f19f;
font-weight: bold;
}

.highlightedTitle{
    background-color: #f3f65a;
}

.selectDeviceDropdown{
    padding: 1rem;
    margin-top: 30px;
}
```

## styles/scss/Sidebar.module.scss

```text
.sidebar {
    position: absolute;
    top: 0;
    display: flex;
    flex-direction: column;
    width: 350px;
    height: 100%;
    background-color: white;
    color: black;
    transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
    box-sizing: border-box;
    border-radius: 5px;
    
}

.left {
    left: 0;
    transform: translateX(-100%);
}

.right {
    right: 0;
    transform: translateX(105%);
}

.open {
    transform: translateX(0);
    opacity: 1;
    visibility: visible;
    pointer-events: auto;
}

.zIndex200 {
    z-index: 200;
}

.zIndex300 {
    z-index: 300;
}

.closeButton {
    background-color: transparent;
    border: none;
    color: black;
    margin: 0.5rem;
    position: absolute;
    right: 0;
    top: 0;
    cursor: pointer
}

.closeIcon {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    cursor: pointer;
    z-index: 1001;
    width: 50px;
    height: 65px;
    background-color: #ffffff;
    border: 2px solid #4b4b4b;
    transition: right 0.4s ease, left 0.4s ease;
    display: flex;
    align-items: center;
    border-radius: 10px;
}

.rightCloseIcon {
    right: -20px;
    justify-content: end;
}

.rightCloseIcon:hover {
    right: -30px;
}

.leftCloseIcon {
    left: -23px;
    justify-content: start;
}

.leftCloseIcon:hover {
    left: -33px;
}

.closeIcon:hover {
    border-color: #000;
}

.sidebarCloseIcon {
    transition: color .2s ease-in;
}

.sidebarCloseIcon:hover {
    //  stroke-width: 1.8px;
    color: #464646;
}
```

## styles/scss/Table.module.scss

```text
.tableWrapper {
    overflow-x: auto;
    width: 100%;
    max-width: 100%;
    // max-height: calc(100vh - 197px);
}


.table {
    width: max-content;
    min-width: 100%;
    border-collapse: collapse;
    font-family: Arial, Helvetica, sans-serif;
}

.cell {
    border: 1px solid #ddd;
    padding: 8px;
    min-width: 180px;
    height: 50px;
    word-wrap: break-word;
    // transition: background-color 0.8s ease
}

.highlightedCell {
    // background-color: #f3f19f;
    font-weight: bold;
}

.highlightedRow {
    background-color: #ddd !important;
    border: 2px solid #aba80a !important;
}

.row:nth-child(even) {
    background-color: #fbfbfb;
}

.row:hover {
    background-color: #ddd;
}

.rowSelected {
    background-color: #ddd !important;
    border: 2px solid #696464 !important;
}

.header {
    border: 1px solid #ddd;
    padding: 8px;
    text-align: left;
    background-color: white;
    color: black;
    height: 40px;
    cursor: pointer;
    font-weight: bold;
    min-width: 180px;

    .sortIcon {
        display: flex;
        align-items: center;
        gap: 1.5rem;
    }
}

.tableBody {
    width: max-content;
    min-width: 100%;
    max-height: 490px;
    overflow-y: scroll;

    // Hide scrollbar by default
    &::-webkit-scrollbar {
        width: 3px;
        background: transparent;
    }

    &::-webkit-scrollbar-thumb {
        background-color: transparent;
        transition: background-color 0.3s;
        border-radius: 25px;
    }

    &::-webkit-scrollbar-track {
        background: transparent;
    }

    // Show thumb on hover
    &:hover::-webkit-scrollbar-thumb {
        background-color: rgba(31, 30, 30, 0.3);
    }

    &::-webkit-scrollbar-thumb:hover {
        background-color: #5e5e5e;
        ; // darker on hover
    }

    &:hover::-webkit-scrollbar-track {
        background-color: #f5f5f5;
    }
}

.tableHeader {
     margin-right: 3px;
}
```

## styles/scss/utilities.scss

```text
//variables
$colors: (
  primary: #007bff,
  success: #28a745,
  danger: #dc3545,
  warning: #ffc107,
  info: #17a2b8,
  neutral: #eee,
  light: #f8f9fa,
  dark: #000,
  darkgray: #333333,
  criticalAlarm : #d32f2f,
  warningAlarm : #fbc02d,
  infoAlarm : #0288d1
);

// spacing scale
$space-scale: (
  0: 0,
  1: 0.25rem,
  2: 0.5rem,
  3: 1rem,
  4: 1.5rem,
  5: 3rem
);

// margin and padding helpers
@each $key, $value in $space-scale {
  .m-#{$key}   { margin: $value !important; }
  .mt-#{$key}  { margin-top: $value !important; }
  .mr-#{$key}  { margin-right: $value !important; }
  .mb-#{$key}  { margin-bottom: $value !important; }
  .ml-#{$key}  { margin-left: $value !important; }
  .mx-#{$key}  { margin-left: $value !important; margin-right: $value !important; }
  .my-#{$key}  { margin-top: $value !important; margin-bottom: $value !important; }

  .p-#{$key}   { padding: $value !important; }
  .pt-#{$key}  { padding-top: $value !important; }
  .pr-#{$key}  { padding-right: $value !important; }
  .pb-#{$key}  { padding-bottom: $value !important; }
  .pl-#{$key}  { padding-left: $value !important; }
  .px-#{$key}  { padding-left: $value !important; padding-right: $value !important; }
  .py-#{$key}  { padding-top: $value !important; padding-bottom: $value !important; }
}


// Width utilities
.w-100 { width: 100% !important; }
.w-75  { width: 75% !important; }
.w-50  { width: 50% !important; }
.w-25  { width: 25% !important; }
.w-auto { width: auto !important; }

// Height utilities
.h-100 { height: 100% !important; }
.h-75  { height: 75% !important; }
.h-50  { height: 50% !important; }
.h-25  { height: 25% !important; }
.h-auto { height: auto !important; }


// Text alignment
.text-center { text-align: center !important; }
.text-left   { text-align: left !important; }
.text-right  { text-align: right !important; }


// Flexbox utilities
.d-flex { display: flex !important; }
.flex-col { flex-direction: column !important; }
.justify-center { justify-content: center !important; }
.align-center { align-items: center !important; }
```

## utils/customhooks/useDeviceAlertSocket.ts

```typescript
import { getSignalRConnection } from "@/sockets/signalRConnection";
import { useEffect } from "react";
import { alarmServiceBaseURL } from "../helpervariables";

export function useDeviceAlertSocket(deviceId : any,onUpdate: (data: any) => void, connMethodName : string, shouldConnectSignalR : boolean = true) {
  useEffect(() => {
    if (!shouldConnectSignalR) return;
    let conn: signalR.HubConnection | null = null;
    const handler = (data: any) => onUpdate(data);

    const setupConnection = async () => {
      conn = await getSignalRConnection();
      if (!conn) {
        console.warn("SignalR connection not available");
        return;
      }else{
        console.log("SignalR connection obtained");
        console.log(`Subscribing to '${connMethodName}'`);
        try {
          if(connMethodName == "ReceiveAlarmPanelUpdates")
              await conn.invoke("JoinAlarmPanelGroup", "AlarmPanelGroup");
          else if(connMethodName == "ReceivePropertyPanelAlarmUpdates")
              await conn.invoke("JoinPropertyPanelGroup", deviceId);
        } catch (err) {
          console.log("JoinDeviceGroup failed:", err);
        }
        conn.on(connMethodName, handler);
      }

    };

    setupConnection();

    return () => {
      if (conn) {
        console.log(`Cleaning up '${connMethodName}' listener`);
        conn.off("ReceiveMainPageUpdates", handler);
        conn.off("ReceiveAlarmPanelUpdates", handler);
        conn.off("ReceivePropertyPanelAlarmUpdates", handler);
        if(connMethodName == "ReceiveAlarmPanelUpdates")
            conn.invoke("LeaveAlarmPanelGroup", "AlarmPanelGroup").catch(console.error);
        else if(connMethodName == "ReceivePropertyPanelAlarmUpdates")
            conn.invoke("LeavePropertyPanelGroup", deviceId);
      }
    };
  }, [deviceId, shouldConnectSignalR]);
}


// -ReceiveMainPageUpdates
// -ReceiveAlarmPanelUpdates
// -ReceivePropertyPanelAlarmUpdates
```

## utils/customhooks/useDeviceDetailSocket.ts

```typescript
import { getSignalRConnection } from "@/sockets/signalRConnection";
import { useEffect } from "react";
import { baseURL } from "../helpervariables";

export function useDeviceDetailSocket(deviceId: string, onDetailUpdate: (data: any) => void, shouldConnectSignalR : boolean = true) {
   useEffect(() => {
    if (!shouldConnectSignalR) return;
    if (!deviceId) return;

    let isSubscribed = true;
    let conn: signalR.HubConnection | null = null;
    const eventName = `DeviceUpdate-${deviceId}`;
    const handler = (data: any) => {
      if (isSubscribed) {
        onDetailUpdate(data);
      }
    };

    const setup = async () => {
      conn = await getSignalRConnection();
      if (!conn) {
        console.warn("SignalR connection not available");
        return;
      }

      console.log("SignalR connection obtained");
      console.log(`Subscribing to 'DeviceDetailsUpdate'`);
      try {
        await conn.invoke("JoinDeviceGroup", deviceId);
      } catch (err) {
        console.log("JoinDeviceGroup failed:", err);
      }

      conn.on(eventName, handler);
    };

    setup();

    return () => {
      isSubscribed = false;

      if (conn) {
        console.log("Cleaning up 'DeviceDetailsUpdate' listener");
        conn.off(eventName, handler);
        conn.invoke("LeaveDeviceGroup", deviceId).catch(console.error);
      }
    };
  }, [deviceId, shouldConnectSignalR]);
}
```

## utils/customhooks/useDevicesTopDataSocket.ts

```typescript
import { getSignalRConnection } from "@/sockets/signalRConnection";
import { useEffect, useRef } from "react";
import { baseURL } from "../helpervariables";

export function useDevicesTopDataSocket(onUpdate: (data: any) => void) {
  const onUpdateRef = useRef(onUpdate);

  useEffect(() => {
    onUpdateRef.current = onUpdate;
  }, [onUpdate]);

  useEffect(() => {
    let conn: signalR.HubConnection | null = null;

    const handler = (data: any) => {
      onUpdateRef.current?.(data);
    };

    const setupConnection = async () => {
      conn = await getSignalRConnection();
      if (!conn) {
        console.warn("SignalR connection not available");
        return;
      }

      console.log("SignalR connected. Subscribing to 'ReceiveUpdate'");
      conn.on("ReceiveUpdate", handler);
    };

    setupConnection();

    return () => {
      if (conn) {
        console.log("Cleaning up SignalR 'ReceiveUpdate' listener");
        conn.off("ReceiveUpdate", handler);
      }
    };
  }, []);
}
```

## utils/deepDiff.ts

```typescript
export function getChangedPaths(
  original: any,
  diff: any,
  path: string = '',
  labelPath: string = ''
): string[] {
  const changes: string[] = [];

  if (Array.isArray(diff)) {
    for (let i = 0; i < diff.length; i++) {
      const val2 = diff[i];
      const val1 = original?.[i];

      const structuralPath = `${path}[${i}]`;
      const arrayKey = path.split('.').pop() ?? 'Item';
      const labelPathForItem = `${labelPath}.${arrayKey} ${i}`;

      if (
        typeof val1 === 'object' &&
        typeof val2 === 'object' &&
        val1 !== null &&
        val2 !== null
      ) {
        changes.push(...getChangedPaths(val1, val2, structuralPath, labelPathForItem));
      } else if (val1 !== val2) {
        changes.push(labelPathForItem);
      }
    }

    return changes;
  }

  if (typeof diff === 'object' && diff !== null) {
    for (const key of Object.keys(diff)) {
      const val2 = diff[key];
      const val1 = original?.[key];

      const nextPath = path ? `${path}.${key}` : key;
      const nextLabelPath = labelPath ? `${labelPath}.${key}` : key;

      if (
        typeof val1 === 'object' &&
        typeof val2 === 'object' &&
        val1 !== null &&
        val2 !== null
      ) {
        changes.push(...getChangedPaths(val1, val2, nextPath, nextLabelPath));
      } else if (val1 !== val2) {
        changes.push(nextLabelPath);
      }
    }

    return changes;
  }

  // diff is a primitive and doesn't match the original
  if (original !== diff && labelPath) {
    return [labelPath];
  }

  return [];
}
```

## utils/helperfunctions.ts

```typescript
import { ICONS } from "./helpervariables";

//function to capitalize first letter of the input text
export function capitalizeFirstLetter(val: string) {
  return String(val).charAt(0).toUpperCase() + String(val).slice(1);
}

export function handleAxiosError(error: any) {
  if (error.response) {
    // Server responded with a status code outside the 2xx range
    console.error("Server responded with an error:", error.response.status, error.response.data);
  } else if (error.request) {
    // Request was made, but no response received
    console.error("No response received. Server may be down or unreachable.");
  } else {
    // Something else happened
    console.error("Error setting up the request:", error.message);
  }
}

export function formatRelativeTime(timestamp: string): string {
  const time = new Date(timestamp);
  const now = new Date();
  const diffMs = now.getTime() - time.getTime();

  const minutes = Math.floor(diffMs / (1000 * 60));
  const hours = Math.floor(diffMs / (1000 * 60 * 60));
  const days = Math.floor(diffMs / (1000 * 60 * 60 * 24));

  if (minutes < 60) {
    return `${minutes} minute${minutes !== 1 ? 's' : ''} ago`;
  } else if (hours < 24) {
    return `${hours} hour${hours !== 1 ? 's' : ''} ago`;
  } else {
    return `${days} day${days !== 1 ? 's' : ''} ago`;
  }
}


export function formatDateTime(datetime: string): string {
  const date = new Date(datetime);
    return new Intl.DateTimeFormat('en-US', {
      dateStyle: 'short',
      timeStyle: 'medium'
    }).format(date)
}

//function to get all ancestors path of a given path
export function getAncestorPaths(path: string): string[] {
  const parts = path.split(".");
  const ancestors: string[] = [];

  for (let i = 1; i < parts.length; i++) {
    ancestors.push(parts.slice(0, i).join("."));
  }

  return ancestors;
}

//function to get collapsed accordion titles to highlight
export function getCollapsedAncestorsToHighlight(
  highlightedPaths: string[],
  accordionStates: Record<string, boolean>
): Set<string> {
  const result = new Set<string>();

  for (const path of highlightedPaths) {
    const ancestors = getAncestorPaths(path);

    for (const ancestor of ancestors) {        
      const isCollapsed = accordionStates[ancestor] === false;
      if (isCollapsed) {
        result.add(ancestor);
      }
    }
  }

  return result;
}

//React diagram related helper functions
export const getIcon = (type: string): string => ICONS[type] || "ðŸ”˜";
```

## utils/helpervariables.ts

```typescript
//local
export const baseURL = "https://localhost:7127";
export const alarmServiceBaseURL = "https://localhost:7154";
export const websocketGatewayUrl = "https://localhost:7169/ws/gateway";

//docker
// export const baseURL = "http://localhost:7127";
// export const alarmServiceBaseURL = "http://localhost:7154"; 



export const sampleTableData = [
  {
    "ID": 1,
    "Name": "Alice",
    "Age": 25,
    "Country": "USA",
    "Occupation": "Engineer",
    "Salary": 75000
  },
  {
    "ID": 2,
    "Name": "Bob",
    "Age": 30,
    "Country": "Canada",
    "Occupation": "Designer",
    "Salary": 65000
  },
  {
    "ID": 3,
    "Name": "Charlie",
    "Age": 28,
    "Country": "UK",
    "Occupation": "Doctor",
    "Salary": 85000
  },
  {
    "ID": 4,
    "Name": "David",
    "Age": 35,
    "Country": "Australia",
    "Occupation": "Teacher",
    "Salary": 55000
  },
  {
    "ID": 5,
    "Name": "Eve",
    "Age": 22,
    "Country": "India",
    "Occupation": "Artist",
    "Salary": 40000
  },
  {
    "ID": 6,
    "Name": "Frank",
    "Age": 40,
    "Country": "Germany",
    "Occupation": "Scientist",
    "Salary": 90000
  },
  {
    "ID": 7,
    "Name": "Grace",
    "Age": 27,
    "Country": "France",
    "Occupation": "Chef",
    "Salary": 60000
  },
  {
    "ID": 8,
    "Name": "Hank",
    "Age": 32,
    "Country": "Japan",
    "Occupation": "Musician",
    "Salary": 72000
  },
  {
    "ID": 9,
    "Name": "Ivy",
    "Age": 29,
    "Country": "Brazil",
    "Occupation": "Dancer",
    "Salary": 48000
  },
  {
    "ID": 10,
    "Name": "Jack",
    "Age": 31,
    "Country": "South Africa",
    "Occupation": "Photographer",
    "Salary": 53000
  }
];

export const severities = [
  "Critical", "Warning", "Information"
]


//React diagram related helper variables

export const ICONS: Record<string, string> = {
  "Networking Device": "ðŸ“¡",
  "Personal Device": "ðŸ’»",
  "Peripheral Device": "ðŸ–¨ï¸",
  "Smart Appliance": "â„ï¸",
  "Entertainment Device": "ðŸ“º",
  "Surveillance Device": "ðŸ“·",
  "Server": "ðŸ–¥ï¸",
  "Microcomputer": "ðŸ“",
};
```

## utils/propertypanelfunctions.tsx

```text
import React, { useCallback, useEffect, useMemo, useState } from "react";
import styles from "@/styles/scss/PropertyPanel.module.scss";
import KeyValueField from "@/components/customcomponents/Propertypanel/KeyValueField";
import Accordion from "@/components/customcomponents/Accordion";

export const renderKeyValueSection = (
  key: string,
  value: any,
  depth: number,
  parentPath: string,
  highlightedPaths: string[]
) => {
  const fullPath = parentPath ? `${parentPath}.${key}` : key;
  return (
    <KeyValueField
      key={fullPath}
      keyName={key}
      value={value}
      depth={depth}
      fullPath={fullPath}
      highlightedPaths={highlightedPaths}
    />
  );
};

export const renderObject = (
  key: string,
  data: any,
  depth = 1,
  parentPath = "",
  highlightedPaths: string[],
  collapsedTitlesToHighlight: Set<string>,
) => {
  const fullPath = parentPath ? `${parentPath}.${key}` : key;
  const shouldHighlightTitle = collapsedTitlesToHighlight.has(fullPath);

  if (!data || typeof data !== "object") return null;

  if (Array.isArray(data)) {
    return renderArray(key, data, depth, parentPath, highlightedPaths, collapsedTitlesToHighlight);
  }

  return (
    <Accordion
      keyPath={fullPath}
      key={fullPath}
      title={
        <span className={`${styles.propertyPanelTitles} ${styles[`depth-${depth}`]} ${shouldHighlightTitle ? styles.highlightedTitle : ""}`}>
          {key}
        </span>
      }
      defaultOpen={true}
      bgColor="white"
    >
      <div className={styles.keyValueSection}>
        {Object.entries(data).map(([childKey, childVal]) => {
          const childPath = `${fullPath}.${childKey}`;
          if (Array.isArray(childVal)) {
            return renderArray(childKey, childVal, depth + 1, fullPath, highlightedPaths, collapsedTitlesToHighlight);
          } else if (typeof childVal === "object" && childVal !== null) {
            return renderObject(childKey, childVal, depth + 1, fullPath, highlightedPaths, collapsedTitlesToHighlight);
          } else {
            return renderKeyValueSection(childKey, childVal, depth + 1, fullPath, highlightedPaths);
          }
        })}
      </div>
    </Accordion>
  );
};

export const renderArray = (
  key: string,
  data: any[],
  depth: number,
  parentPath = "",
  highlightedPaths: string[],
  collapsedTitlesToHighlight: Set<string>
) => {
  if (!data || data.length === 0) return null;

  const fullPath = parentPath ? `${parentPath}.${key}` : key;
  const shouldHighlightTitle = collapsedTitlesToHighlight.has(fullPath);

  return (
    <Accordion
      keyPath={fullPath}
      key={fullPath}
      title={
        <span className={`${styles.propertyPanelTitles} ${styles[`depth-${depth}`]} ${shouldHighlightTitle ? styles.highlightedTitle : ""}`}>
          {key}
        </span>
      }
      defaultOpen={true}
      bgColor="white"
    >
      <div className={styles.keyValueSection}>
        {data.map((item, idx) => {
          const itemPath = `${fullPath}`;

          const displayLabel = `${key} ${idx}`;

          if (typeof item === "object" && item !== null) {
            return renderObject(displayLabel, item, depth + 1, itemPath, highlightedPaths, collapsedTitlesToHighlight);
          } else {
            return renderKeyValueSection(displayLabel, item, depth + 1, itemPath, highlightedPaths);
          }
        })}
      </div>
    </Accordion>
  );
};

export function deepMerge(target: any, source: any): any {
  if (Array.isArray(target) && Array.isArray(source)) {
    // Merge arrays element-wise
    return target.map((item, index) => deepMerge(item, source[index] ?? item));
  }

  if (typeof target === "object" && typeof source === "object") {
    const result: any = { ...target };
    for (const key of Object.keys(source)) {
      if (key in target) {
        result[key] = deepMerge(target[key], source[key]);
      } else {
        result[key] = source[key];
      }
    }
    return result;
  }

  return source; // For primitives and fallback
}
```

## __tests__/components/Accordion.test.tsx

```text
import Accordion from "@/components/customcomponents/Accordion";
import { render, screen, fireEvent } from "@testing-library/react";
import '@testing-library/jest-dom';

// Mock styles and icons
jest.mock("@/styles/scss/Accordion.module.scss", () => ({
    accordion: "accordion",
    header: "header",
    tabListHeader: "tabListHeader",
    content: "content",
    open: "open",
}));

jest.mock("lucide-react", () => ({
    ChevronDown: () => <span data-testid="chevron-down" />,
    ChevronUp: () => <span data-testid="chevron-up" />,
}));

// Mock AccordionVisibilityContext
const mockContext = {
    getState: jest.fn(),
    toggle: jest.fn(),
    register: jest.fn(),
};

jest.mock("../../components/customcomponents/Propertypanel/AccordionVisibilityContext", () => ({
    useAccordionState: () => mockContext,
}));

describe("Accordion", () => {
    beforeEach(() => {
        jest.clearAllMocks();
    });

    it("renders with title and children", () => {
        render(
            <Accordion title="Test Title">
                <div>Test Content</div>
            </Accordion>
        );
        expect(screen.getByText("Test Title")).toBeInTheDocument();
        expect(screen.getByText("Test Content")).toBeInTheDocument();
    });

    it("shows ChevronUp when open and ChevronDown when closed", () => {
        render(
            <Accordion title="Test Title" defaultOpen={true}>
                <div>Test Content</div>
            </Accordion>
        );
        expect(screen.getByTestId("chevron-up")).toBeInTheDocument();

        fireEvent.click(screen.getByText("Test Title"));
        expect(screen.getByTestId("chevron-down")).toBeInTheDocument();
    });

    it("toggles open/close state when header is clicked (uncontrolled)", () => {
        render(
            <Accordion title="Toggle Test" defaultOpen={false}>
                <div>Toggle Content</div>
            </Accordion>
        );
        expect(screen.getByTestId("chevron-down")).toBeInTheDocument();

        fireEvent.click(screen.getByText("Toggle Test"));
        expect(screen.getByTestId("chevron-up")).toBeInTheDocument();
    });

    it("applies tabListHeader class when isTabList is true", () => {
        render(
            <Accordion title="TabList Test" isTabList>
                <div>TabList Content</div>
            </Accordion>
        );
        const header = screen.getByText("TabList Test").parentElement;
        expect(header?.className).toContain("tabListHeader");
    });

    it("uses context when keyPath is provided", () => {
        mockContext.getState.mockReturnValue(true);
        render(
            <Accordion title="Context Test" keyPath="panel1">
                <div>Context Content</div>
            </Accordion>
        );
        expect(mockContext.register).toHaveBeenCalledWith("panel1", true);
        expect(screen.getByTestId("chevron-up")).toBeInTheDocument();

        fireEvent.click(screen.getByText("Context Test"));
        expect(mockContext.toggle).toHaveBeenCalledWith("panel1", false);
    });
});
```

## __tests__/components/AlarmPanel/AlarmPanelContent.test.tsx

```text
import React from "react";
import { render, screen, fireEvent } from "@testing-library/react";
import {

    DeviceTags,
    CustomTag,
    AlarmPopUp,
    ProfilePopUp,
} from "@/components/customcomponents/AlarmPanel/AlarmPanelContent";

import "@testing-library/jest-dom";

// Mock Chakra UI Tag components
jest.mock("@chakra-ui/react", () => {
    const Tag = ({ children }: any) => <div>{children}</div>;
    Tag.Root = ({ children, ...props }: any) => <div {...props}>{children}</div>;
    Tag.Label = ({ children }: any) => <span>{children}</span>;
    Tag.EndElement = ({ children }: any) => <span>{children}</span>;
    Tag.CloseTrigger = ({ onClick }: any) => (
        <button data-testid="close-trigger" onClick={onClick}>x</button>
    );
    return {
        HStack: ({ children }: any) => <div>{children}</div>,
        Tag,
    };
});

// Mock styles and icons
jest.mock("@/styles/scss/AlarmPanel.module.scss", () => ({}));
jest.mock("lucide-react", () => ({
    MessagesSquare: () => <span>MessagesSquare</span>,
    Settings2: () => <span>Settings2</span>,
    SquareUser: () => <span>SquareUser</span>,
}));
jest.mock("@/utils/helperfunctions", () => ({
    formatRelativeTime: (date: string) => `formatted-${date}`,
}));

describe("AlarmPanelContent Components", () => {
    describe("DeviceTags", () => {
        it("renders tags and calls removeTag on close", () => {
            const tags = [{ deviceName: "Device1" }, { deviceName: "Device2" }];
            const removeTag = jest.fn();
            render(<DeviceTags tags={tags} removeTag={removeTag} />);
            expect(screen.getByText("Device1")).toBeInTheDocument();
            expect(screen.getByText("Device2")).toBeInTheDocument();

            const closeButtons = screen.getAllByTestId("close-trigger");
            fireEvent.click(closeButtons[0]);
            expect(removeTag).toHaveBeenCalledWith(0);
        });
    });

    describe("CustomTag", () => {
        it("renders tag and triggers removeTag", () => {
            const removeTag = jest.fn();
            render(<CustomTag tag="TestTag" index={5} removeTag={removeTag} />);
            expect(screen.getByText("TestTag")).toBeInTheDocument();
            fireEvent.click(screen.getByTestId("close-trigger"));
            expect(removeTag).toHaveBeenCalledWith(5);
        });
    });

    describe("AlarmPopUp", () => {
        it("renders alarms and triggers setIsAlarmPanelOpen", () => {
            const setIsAlarmPanelOpen = jest.fn();
            const latestAlarms = [
                { id: 1, severity: "Critical", message: "Alarm1", raisedAt: "2024-01-01" },
                { id: 2, severity: "Warning", message: "Alarm2", raisedAt: "2024-01-02" },
            ];
            render(
                <AlarmPopUp
                    setIsAlarmPanelOpen={setIsAlarmPanelOpen}
                    latestAlarms={latestAlarms}
                    totalAlarms={2}
                />
            );
            expect(screen.getByText("Alarm1")).toBeInTheDocument();
            expect(screen.getByText("Alarm2")).toBeInTheDocument();
            expect(screen.getByText("formatted-2024-01-01")).toBeInTheDocument();
            expect(screen.getByText("formatted-2024-01-02")).toBeInTheDocument();

            fireEvent.click(screen.getByText("View all"));
            expect(setIsAlarmPanelOpen).toHaveBeenCalledWith(true);
        });
    });

    describe("ProfilePopUp", () => {
        it("renders profile info and buttons", () => {
            render(<ProfilePopUp />);
            expect(screen.getByText("Welcome, Premal Kadam")).toBeInTheDocument();
            expect(screen.getByText("premal.kadam@wonderbiz.in")).toBeInTheDocument();
            expect(screen.getByText("My Account")).toBeInTheDocument();
            expect(screen.getByText("Notifications")).toBeInTheDocument();
            expect(screen.getByText("Settings")).toBeInTheDocument();
            expect(screen.getByText("Logout")).toBeInTheDocument();
        });

        it("logout button stops event propagation", () => {
            const parentClick = jest.fn();
            render(
                <div onClick={parentClick}>
                    <ProfilePopUp />
                </div>
            );

            fireEvent.click(screen.getByText("Logout"));

            // If stopPropagation worked, parentClick should NOT be called
            expect(parentClick).not.toHaveBeenCalled();
        });
    });
});
```

## __tests__/components/AlarmPanel/CustomModal.test.tsx

```text
import React from "react";
import { render, screen, fireEvent, act } from "@testing-library/react";
import CustomModal from "@/components/customcomponents/AlarmPanel/CustomModal";
import "@testing-library/jest-dom";

jest.useFakeTimers(); // use Jest fake timers for debounce

describe("CustomModal", () => {
  const setIsOpen = jest.fn();
  const actionFunction = jest.fn();

  beforeEach(() => {
    jest.clearAllMocks();
  });

  test("does not render when isOpen is false", () => {
    render(
      <CustomModal
        isOpen={false}
        setIsOpen={setIsOpen}
        title="Alarm"
        actionFunction={actionFunction}
      />
    );

    expect(screen.queryByText("Alarm")).not.toBeInTheDocument();
  });

  test("renders when isOpen is true", () => {
    render(
      <CustomModal
        isOpen={true}
        setIsOpen={setIsOpen}
        title="Alarm Title"
        actionFunction={actionFunction}
      />
    );

    expect(screen.getByText("Alarm Title")).toBeInTheDocument();
    expect(screen.getByPlaceholderText("Comment")).toBeInTheDocument();
  });

  test("closes when Close button is clicked", () => {
    render(
      <CustomModal
        isOpen={true}
        setIsOpen={setIsOpen}
        title="Alarm"
        actionFunction={actionFunction}
      />
    );

    fireEvent.click(screen.getByText("Ã—"));
    expect(setIsOpen).toHaveBeenCalledWith(false);
  });

  test("closes when Cancel button is clicked", () => {
    render(
      <CustomModal
        isOpen={true}
        setIsOpen={setIsOpen}
        title="Alarm"
        actionFunction={actionFunction}
      />
    );

    fireEvent.click(screen.getByText("Cancel"));
    expect(setIsOpen).toHaveBeenCalledWith(false);
  });

  test("does not call actionFunction when Save clicked and comment empty", () => {
    render(
      <CustomModal
        isOpen={true}
        setIsOpen={setIsOpen}
        title="Alarm"
        actionFunction={actionFunction}
      />
    );

    fireEvent.click(screen.getByText("Save"));
    expect(actionFunction).not.toHaveBeenCalled();
  });

  test("updates comment after debounce and calls actionFunction on Save", async () => {
    render(
      <CustomModal
        isOpen={true}
        setIsOpen={setIsOpen}
        title="Alarm"
        actionFunction={actionFunction}
      />
    );

    const textarea = screen.getByPlaceholderText("Comment");

    // Type into textarea
    fireEvent.change(textarea, { target: { value: "Test Comment" } });

    // Fast-forward debounce timer
    act(() => {
      jest.advanceTimersByTime(200);
    });

    // Click Save
    fireEvent.click(screen.getByText("Save"));

    expect(actionFunction).toHaveBeenCalledWith("Test Comment");
    expect(setIsOpen).toHaveBeenCalledWith(false);
  });

  test("stops click propagation inside modal", () => {
    const parentClick = jest.fn();
    render(
        <div onClick={parentClick}>
            <CustomModal
              isOpen={true}
              setIsOpen={setIsOpen}
              title="Alarm"
              actionFunction={actionFunction}
            />

        </div>
    );

    const wrapper = screen.getByTestId("customModalWrapper");

    fireEvent.click(wrapper);

    expect(parentClick).not.toHaveBeenCalled();
  });
});
```

## __tests__/components/AlarmPanel/SelectDevicesComboBox.test.tsx

```text
// SelectDevicesComboBox.test.tsx
import SelectDevicesComboBox from "@/components/customcomponents/AlarmPanel/SelectDevicesComboBox";
import { Provider } from "@/components/ui/provider";
import { render, screen, fireEvent, act } from "@testing-library/react";
import userEvent from "@testing-library/user-event";
import "@testing-library/jest-dom";

class ResizeObserver {
    observe() { }
    unobserve() { }
    disconnect() { }
}

global.ResizeObserver = ResizeObserver;

const mockDevices = [
    { deviceName: "Device A", deviceMacId: "mac-1" },
    { deviceName: "Device B", deviceMacId: "mac-2" },
    { deviceName: "Device C", deviceMacId: "mac-3" },
];

Object.defineProperty(window, 'matchMedia', {
    writable: true,
    value: jest.fn().mockImplementation(query => ({
        matches: false,
        media: query,
        onchange: null,
        addListener: jest.fn(), // deprecated
        removeListener: jest.fn(), // deprecated
        addEventListener: jest.fn(),
        removeEventListener: jest.fn(),
        dispatchEvent: jest.fn(),
    })),
});

describe("SelectDevicesComboBox", () => {
    let selectedDevices: any[] = [];
    const setSelectedDevices = jest.fn((devices) => {
        selectedDevices = devices;
    });

    beforeEach(() => {
        selectedDevices = [];
        jest.clearAllMocks();
    });

    test("renders without crashing", () => {
        render(
            <Provider>
                <SelectDevicesComboBox
                    devices={mockDevices}
                    selectedDevices={selectedDevices}
                    setSelectedDevices={setSelectedDevices}
                />
            </Provider>
        );
        expect(screen.getByPlaceholderText("Select Devices")).toBeInTheDocument();
    });


    test("calls setSelectedDevices when a device is selected", async () => {
        render(
            <Provider>
                <SelectDevicesComboBox
                    devices={mockDevices}
                    selectedDevices={[]}
                    setSelectedDevices={setSelectedDevices}
                />
            </Provider>
        );

        // Click the trigger to open the dropdown
        const toggleButton = screen.getByTestId("comboBoxTrigger");
        await userEvent.click(toggleButton);

        // Select the item
        const item = await screen.findByTestId("mac-1");
        await userEvent.click(item);

        // Check if setSelectedDevices was called with the correct device
        expect(setSelectedDevices).toHaveBeenCalledWith([mockDevices[0]]);
    });

    test("displays selected devices as badges", () => {
        selectedDevices = [mockDevices[0]];
        render(
            <Provider>
                <SelectDevicesComboBox
                    devices={mockDevices}
                    selectedDevices={selectedDevices}
                    setSelectedDevices={setSelectedDevices}
                />
            </Provider>
        );

        expect(screen.getByTestId("Device A")).toBeInTheDocument();
    });

    test("filters devices based on input", async () => {
        render(
            <Provider>
                <SelectDevicesComboBox
                    devices={mockDevices}
                    selectedDevices={selectedDevices}
                    setSelectedDevices={setSelectedDevices}
                />
            </Provider>
        );

        const input = screen.getByPlaceholderText("Select Devices");

        // Type "Device B" in input
        await userEvent.type(input, "D");

        expect(screen.getByText("Device B")).toBeInTheDocument();
        // expect(screen.queryByText("Device A")).not.toBeInTheDocument();
        // expect(screen.queryByText("Device C")).not.toBeInTheDocument();
    });

    test("shows empty message if no devices match search", async () => {
        render(
            <Provider>
                <SelectDevicesComboBox
                    devices={mockDevices}
                    selectedDevices={selectedDevices}
                    setSelectedDevices={setSelectedDevices}
                />
            </Provider>
        );

        const input = screen.getByPlaceholderText("Select Devices");
        await userEvent.type(input, "Non-existent device");

        expect(screen.getByText("No devices found")).toBeInTheDocument();
    });

    test("removes a device when close button is clicked", async () => {
        selectedDevices = [mockDevices[0]];
        render(
            <Provider>
                <SelectDevicesComboBox
                    devices={mockDevices}
                    selectedDevices={selectedDevices}
                    setSelectedDevices={setSelectedDevices}
                />
            </Provider>
        );

        const closeButton = screen.getByLabelText("Close");
        fireEvent.click(closeButton);

        expect(setSelectedDevices).toHaveBeenCalledWith([]);
    });
});
```

## __tests__/components/Badge.test.tsx

```text
import React from 'react';
import { render, screen } from '@testing-library/react';
import '@testing-library/jest-dom';
import Badge from '@/components/customcomponents/Badge';

describe('Badge', () => {
    it('renders the label', () => {
        render(<Badge label="Test Label" />);
        expect(screen.getByText('Test Label')).toBeInTheDocument();
    });

    it('applies default styles when no bgColor or textColor is provided', () => {
        render(<Badge label="Default Styles" />);
        const badge = screen.getByText('Default Styles');
        expect(badge.className).toContain('badge');
    });

    it('applies bgColor and textColor styles when provided', () => {
        render(<Badge label="Colored Badge" bgColor="red" textColor="white" />);
        const badge = screen.getByText('Colored Badge');
        expect(badge.className).toContain('badgebg--red');
        expect(badge.className).toContain('badgetext--white');
    });
});
```

## __tests__/components/ChakraUiComponents/PopOver.test.tsx

```text
import React from "react";
import { render, screen } from "@testing-library/react";
import '@testing-library/jest-dom';
import PopOver from "@/components/chakrauicomponents/PopOver";


jest.mock("@chakra-ui/react", () => {
    const React = require("react");
    const PopoverContext = React.createContext({ open: false });

    const Root = ({ children, open }: any) =>
        React.createElement(PopoverContext.Provider, { value: { open } }, children);

    const Trigger = ({ children }: any) => children;

    const Portal = ({ children }: any) => children;

    const Positioner = ({ children }: any) => {
        const { open } = React.useContext(PopoverContext);
        return open ? React.createElement("div", { "data-testid": "positioner" }, children) : null;
    };

    const Content = ({ children, bgColor }: any) =>
        React.createElement("div", { "data-testid": "content", style: { backgroundColor: bgColor } }, children);

    const Body = ({ children, onMouseEnter, onMouseLeave }: any) =>
        React.createElement("div", { onMouseEnter, onMouseLeave }, children);

    const Button = ({ children, ...rest }: any) =>
        React.createElement("button", rest, children || "button");

    return {
        Button,
        Popover: {
            Root,
            Trigger,
            Positioner,
            Content,
            Body,
        },
        Portal,
    };
});



describe("PopOver component", () => {
    afterEach(() => {
        jest.restoreAllMocks();
    });

    test("renders default trigger when no triggerContent is provided", () => {
        render(<PopOver isOpen={false}>Hidden</PopOver>);
        expect(screen.getByText("Open PopOver")).toBeInTheDocument();
    });

    test("renders custom trigger content when provided", () => {
        render(
            <PopOver isOpen={false} triggerContent={<button>My Trigger</button>}>
                Hidden
            </PopOver>
        );
        expect(screen.getByText("My Trigger")).toBeInTheDocument();
    });

    test("shows children when isOpen is true", () => {
        render(<PopOver isOpen={true}>Visible Popover Content</PopOver>);
        expect(screen.getByText("Visible Popover Content")).toBeInTheDocument();
    });

    test("does not render children when isOpen is false", () => {
        render(<PopOver isOpen={false}>Hidden Popover Content</PopOver>);
        expect(screen.queryByText("Hidden Popover Content")).toBeNull();
    });
});
```

## __tests__/components/ChakraUiComponents/Swithc.test.tsx

```text
import React from "react"
import { render, screen, fireEvent } from "@testing-library/react"
import SwitchComponent from "@/components/chakrauicomponents/SwitchComponent"
import '@testing-library/jest-dom';

// Mock chakra Switch subcomponents
jest.mock("@chakra-ui/react", () => {
    const Root = ({ checked, children, ...rest }: any) => (
        <div
            data-testid="switch-root"
            data-checked={String(checked)}
            data-colorpalette={rest.colorPalette}
            data-size={rest.size}
        >
            {children}
        </div>
    )
    const HiddenInput = () => <input data-testid="hidden-input" />
    const Control = ({ onClick, children }: any) => (
        <button data-testid="switch-control" onClick={onClick}>
            {children}
        </button>
    )
    const Thumb = ({ children }: any) => <div data-testid="switch-thumb">{children}</div>
    const ThumbIndicator = ({ fallback, children }: any) => (
        <div data-testid="switch-thumb-indicator">{children ? children : fallback}</div>
    )

    return {
        Switch: {
            Root,
            HiddenInput,
            Control,
            Thumb,
            ThumbIndicator,
        },
    }
})

// Mock react-icons/hi to render simple text nodes for predictable queries
jest.mock("react-icons/hi", () => ({
    HiCheck: () => <span data-testid="hi-check">HiCheck</span>,
    HiX: () => <span data-testid="hi-x">HiX</span>,
}))

// Mock local Tooltip component used by the component under test
jest.mock("../../../components/ui/tooltip", () => {
    return {
        Tooltip: ({ children, content }: any) => (
            <div data-testid="tooltip">
                {children}
                <div data-testid="tooltip-content">
                    {content}
                </div>
            </div>
        ),
    }
})


describe("SwitchComponent - returnSwitch", () => {
    test("renders switch with checked state and invokes toggle on control click", () => {
        const toggle = jest.fn()
        render(<SwitchComponent enabled={true} toggle={toggle} />)

        const root = screen.getByTestId("switch-root")
        expect(root).toHaveAttribute("data-checked", "true")
        expect(root).toHaveAttribute("data-colorpalette", "green")
        expect(root).toHaveAttribute("data-size", "md")

        // Icon present
        expect(screen.getByTestId("hi-check")).toBeInTheDocument()

        // Click the control to invoke toggle
        const control = screen.getByTestId("switch-control")
        fireEvent.click(control)
        expect(toggle).toHaveBeenCalledTimes(1)
    })

    test("wraps switch with Tooltip when tooltip prop provided and still clickable", () => {
        const toggle = jest.fn()
        const tooltipText = "Helpful tooltip"
        render(<SwitchComponent enabled={false} toggle={toggle} tooltip={tooltipText} />)

        // Tooltip wrapper exists and contains provided tooltip text
        const tooltip = screen.getByTestId("tooltip")
        expect(tooltip).toBeInTheDocument()
        expect(screen.getByTestId("tooltip-content")).toHaveTextContent(tooltipText)

        // Switch root reflects disabled state
        const root = screen.getByTestId("switch-root")
        expect(root).toHaveAttribute("data-checked", "false")

        // Clicking inside tooltip-wrapped control still triggers toggle
        const control = screen.getByTestId("switch-control")
        fireEvent.click(control)
        expect(toggle).toHaveBeenCalledTimes(1)
    })
})
```

## __tests__/components/Pagination.test.tsx

```text
import React from "react";
import { render, fireEvent, screen, getByTestId } from "@testing-library/react";
import Pagination from "@/components/customcomponents/Pagination";
import '@testing-library/jest-dom';

describe("Pagination", () => {
    const defaultProps = {
        currentPage: 2,
        totalPages: 5,
        pageSize: 10,
        pageSizeOptions: [5, 10, 20],
        setCurrentPage: jest.fn(),
        setPageSize: jest.fn(),
    };

    it("renders page numbers and navigation buttons", () => {
        render(<Pagination {...defaultProps} />);
        expect(screen.getByText("1")).toBeInTheDocument();
        expect(screen.getByText("2")).toBeInTheDocument();
        expect(screen.getByText("5")).toBeInTheDocument();
        expect(screen.getByTestId("previous-button")).toBeInTheDocument();
        expect(screen.getByTestId("next-button")).toBeInTheDocument();
    });

    it("calls setCurrentPage when a page number is clicked", () => {
        render(<Pagination {...defaultProps} />);
        fireEvent.click(screen.getByText("3"));
        expect(defaultProps.setCurrentPage).toHaveBeenCalledWith(3);
    });

    it("disables previous button on first page", () => {
        render(<Pagination {...defaultProps} currentPage={1} />);
        expect(screen.getByTestId("previous-button")).toBeDisabled();
    });

    it("disables next button on last page", () => {
        render(<Pagination {...defaultProps} currentPage={5} />);
        expect(screen.getByTestId("next-button")).toBeDisabled();
    });

    it("calls setCurrentPage when previous and next buttons are clicked", () => {
        render(<Pagination {...defaultProps} />);
        fireEvent.click(screen.getByTestId("previous-button"));
        expect(defaultProps.setCurrentPage).toHaveBeenCalledWith(1);
        fireEvent.click(screen.getByTestId("next-button"));
        expect(defaultProps.setCurrentPage).toHaveBeenCalledWith(3);
    });

    it("renders page size options and calls setPageSize on change", () => {
        render(<Pagination {...defaultProps} />);
        const select = screen.getByRole("combobox");
        fireEvent.change(select, { target: { value: "5" } });
        expect(defaultProps.setPageSize).toHaveBeenCalledWith(5);
    });

    it("shows correct page info", () => {
        render(<Pagination {...defaultProps} />);
        expect(screen.getByText("Page 2 of 5")).toBeInTheDocument();
    });

    it("renders ellipsis for large number of pages", () => {
        render(
            <Pagination
                {...defaultProps}
                totalPages={10}
                currentPage={1}
            />
        );
        expect(screen.getAllByText("...").length).toBeGreaterThan(0);
    });

    it("shows ChevronDown when select is closed", () => {
        const { getByRole } = render(<Pagination {...defaultProps} />);
        // Initially, select is closed
        expect(getByRole("combobox")).toBeInTheDocument();
        // Should show ChevronDown
        expect(screen.getByTestId("pageSize-chevrondown")).toBeInTheDocument();
    });

    it("shows ChevronUp when select is open", () => {
        const { getByRole } = render(<Pagination {...defaultProps} />);
        const select = getByRole("combobox");
        // Focus the select to open
        fireEvent.focus(select);
        // Should show ChevronUp
        expect(screen.getByTestId("pageSize-chevronup")).toBeInTheDocument();
    });
});
```

## __tests__/components/PropertyPanel/AccordionVisibilityContext.test.tsx

```text
import React from "react";
import { render, act } from "@testing-library/react";
import { AccordionStateProvider, useAccordionState } from "@/components/customcomponents/Propertypanel/AccordionVisibilityContext";
import '@testing-library/jest-dom';

const TestComponent = () => {
    const context = useAccordionState();
    if (!context) return null;
    const { register, toggle, getState } = context;

    // For testing, register and toggle on mount
    React.useEffect(() => {
        register("panel1", false);
        register("panel2", true);
        toggle("panel1", true);
        toggle("panel2", false);
    }, []);

    return (
        <div>
            <span data-testid="panel1">{String(getState("panel1"))}</span>
            <span data-testid="panel2">{String(getState("panel2"))}</span>
            <span data-testid="panel3">{String(getState("panel3"))}</span>
        </div>
    );
};

describe("AccordionVisibilityContext", () => {
    it("registers and toggles accordion state correctly", () => {
        const { getByTestId } = render(
            <AccordionStateProvider>
                <TestComponent />
            </AccordionStateProvider>
        );

        // panel1 was registered as false, then toggled to true in useEffect of TestComponent
        expect(getByTestId("panel1").textContent).toBe("true");
        // panel2 was registered as true, then toggled to false in useEffect of TestComponent
        expect(getByTestId("panel2").textContent).toBe("false");
        // panel3 was never registered
        expect(getByTestId("panel3").textContent).toBe("undefined");
    });

    it("does not overwrite existing registration", () => {
        let context: ReturnType<typeof useAccordionState> | null = null;

        const RegisterTwice = () => {
            context = useAccordionState();
            React.useEffect(() => {
                context?.register("panelX", false);
                context?.register("panelX", true); // Should not overwrite
            }, []);
            return <span data-testid="panelX">{String(context?.getState("panelX"))}</span>;
        };

        const { getByTestId } = render(
            <AccordionStateProvider>
                <RegisterTwice />
            </AccordionStateProvider>
        );

        expect(getByTestId("panelX").textContent).toBe("false");
    });

    it("returns undefined for unregistered panels", () => {
        let context: ReturnType<typeof useAccordionState> | null = null;

        const Unregistered = () => {
            context = useAccordionState();
            return <span data-testid="unregistered">{String(context?.getState("notRegistered"))}</span>;
        };

        const { getByTestId } = render(
            <AccordionStateProvider>
                <Unregistered />
            </AccordionStateProvider>
        );

        expect(getByTestId("unregistered").textContent).toBe("undefined");
    });
});
```

## __tests__/components/PropertyPanel/KeyValueField.test.tsx

```text
import React from "react";
import { render, screen } from "@testing-library/react";
import KeyValueField from "@/components/customcomponents/Propertypanel/KeyValueField";
import '@testing-library/jest-dom';
const { areEqual } = require("@/components/customcomponents/Propertypanel/KeyValueField");

jest.mock("@/styles/scss/PropertyPanel.module.scss", () => ({
    kvRow: "kvRow",
    kvKey: "kvKey",
    kvValue: "kvValue",
    highlight: "highlight",
    "depth-0": "depth-0",
    "depth-1": "depth-1",
    "depth-2": "depth-2",
    "depth-3": "depth-3",
}));

describe("KeyValueField", () => {
    const defaultProps = {
        keyName: "Test Key",
        value: "Test Value",
        depth: 1,
        fullPath: "root.test",
        highlightedPaths: [],
    };

    it("renders key and value correctly", () => {
        render(<KeyValueField {...defaultProps} />);
        expect(screen.getByText("Test Key")).toBeInTheDocument();
        expect(screen.getByText("Test Value")).toBeInTheDocument();
    });

    it("applies correct depth class", () => {
        render(<KeyValueField {...defaultProps} depth={3} />);
        const keyElement = screen.getByText("Test Key");
        expect(keyElement.className).toContain("depth-3");
    });

    it("renders boolean value as 'Yes' or 'No'", () => {
        const { rerender } = render(
            <KeyValueField {...defaultProps} value={true} />
        );
        expect(screen.getByText("Yes")).toBeInTheDocument();

        rerender(<KeyValueField {...defaultProps} value={false} />);
        expect(screen.getByText("No")).toBeInTheDocument();
    });

    it("applies highlight class when path is highlighted", () => {
        render(
            <KeyValueField
                {...defaultProps}
                highlightedPaths={["root.test"]}
                fullPath="root.test"
            />
        );
        const valueElement = screen.getByText("Test Value");
        expect(valueElement.className).toContain("highlight");
    });

    it("does not apply highlight class when path is not highlighted", () => {
        render(
            <KeyValueField
                {...defaultProps}
                highlightedPaths={["other.path"]}
                fullPath="root.test"
            />
        );
        const valueElement = screen.getByText("Test Value");
        expect(valueElement.className).not.toContain("highlight");
    });

    //areEqual function tests
    describe("areEqual", () => {
        it("returns true if value and highlight status are unchanged", () => {
            const prevProps = {
                value: "foo",
                highlightedPaths: ["a.b"],
                fullPath: "a.b"
            };
            const nextProps = {
                value: "foo",
                highlightedPaths: ["a.b"],
                fullPath: "a.b"
            };
            expect(areEqual(prevProps, nextProps)).toBe(true);
        });

        it("returns false if value has changed", () => {
            const prevProps = {
                value: "foo",
                highlightedPaths: ["a.b"],
                fullPath: "a.b"
            };
            const nextProps = {
                value: "bar",
                highlightedPaths: ["a.b"],
                fullPath: "a.b"
            };
            expect(areEqual(prevProps, nextProps)).toBe(false);
        });

        it("returns false if highlight status changes from not highlighted to highlighted", () => {
            const prevProps = {
                value: "foo",
                highlightedPaths: [],
                fullPath: "a.b"
            };
            const nextProps = {
                value: "foo",
                highlightedPaths: ["a.b"],
                fullPath: "a.b"
            };
            expect(areEqual(prevProps, nextProps)).toBe(false);
        });

        it("returns false if highlight status changes from highlighted to not highlighted", () => {
            const prevProps = {
                value: "foo",
                highlightedPaths: ["a.b"],
                fullPath: "a.b"
            };
            const nextProps = {
                value: "foo",
                highlightedPaths: [],
                fullPath: "a.b"
            };
            expect(areEqual(prevProps, nextProps)).toBe(false);
        });

        it("returns true if fullPath is not in highlightedPaths in both prev and next", () => {
            const prevProps = {
                value: "foo",
                highlightedPaths: ["x.y"],
                fullPath: "a.b"
            };
            const nextProps = {
                value: "foo",
                highlightedPaths: ["z.w"],
                fullPath: "a.b"
            };
            expect(areEqual(prevProps, nextProps)).toBe(true);
        });
    });
});
```

## __tests__/components/PropertyPanel/PropertyPanel.test.tsx

```text
import React from "react";
import { render, screen, fireEvent, waitFor } from "@testing-library/react";
import PropertyPanel from "@/components/customcomponents/Propertypanel/PropertyPannel";
const mockGetPropertyPanelData = require("@/services/deviceservice").getPropertyPanelData;
import '@testing-library/jest-dom';
import TabList from "@/components/customcomponents/Propertypanel/TabList";

// Mock dependencies
jest.mock("@/components/customcomponents/Accordion", () => ({ children, ...props }: any) => <div data-testid="accordion"><TabList
    highlightedPaths={props.highlightedPaths}
    activeTab={props.activeTab}
    setActiveTab={props.setActiveTab}
/>{children}</div>);

const setActiveTab = jest.fn();
jest.mock("@/components/customcomponents/Propertypanel/TabList", () => ({ highlightedPaths, activeTab }: any) => (
    <div data-testid="tablist">
        <button onClick={() => (setActiveTab || (() => { }))("Static")}>Static</button>
        <button onClick={() => (setActiveTab || (() => { }))("Health")}>Health</button>
    </div>
));

jest.mock("@/components/customcomponents/Propertypanel/PropertyPanelContent", () => ({
    HealthTabContent: ({ deviceName }: any) => <div data-testid="health-tab">Health tab content</div>,
    StaticTabContent: ({ staticProps }: any) => <div data-testid="static-tab">{JSON.stringify(staticProps)}</div>,
}));

jest.mock("@/services/deviceservice", () => ({
    getPropertyPanelData: jest.fn(),
}));

jest.mock("@/utils/customhooks/useDeviceDetailSocket", () => ({
    useDeviceDetailSocket: jest.fn(),
}));

jest.mock("@/components/customcomponents/AlarmPanel/SelectDevicesComboBox", () => ({ devices, selectedDevices, setSelectedDevices }: any) => (
    <select
        data-testid="combobox"
        value={selectedDevices[0]?.deviceMacId || ""}
        onChange={e => setSelectedDevices([{ deviceMacId: e.target.value }])}
    >
        {devices.map((d: any) => (
            <option key={d.deviceMacId} value={d.deviceMacId}>{d.deviceName}</option>
        ))}
    </select>
));

jest.mock("@/components/customcomponents/Propertypanel/AccordionVisibilityContext", () => ({
    AccordionStateProvider: ({ children }: any) => <>{children}</>,
}));

describe("PropertyPanel", () => {
    const defaultProps = {
        setCurrentDeviceId: jest.fn(),
        setCurrentDeviceFileName: jest.fn(),
        deviceFileNames: { "mac1": "file1" },
        devicesNameMacList: [{ deviceMacId: "mac1", deviceName: "Device 1" }],
        setIsAlarmPanelOpen: jest.fn(),
        setSelectedDevicePropertyPanel: jest.fn(),
        currentDeviceId: "mac1",
        currentDeviceFileName: "file1",
        activeTab: "Static",
        setActiveTab,
    };

    beforeEach(() => {
        jest.clearAllMocks();
    });

    it("renders select device dropdown when no data", () => {
        render(<PropertyPanel {...defaultProps} currentDeviceId={null} currentDeviceFileName={null} />);
        expect(screen.getByText("Select device")).toBeInTheDocument();
        expect(screen.getByTestId("combobox")).toBeInTheDocument();
    });

    it("renders property panel data when data is present", async () => {
        mockGetPropertyPanelData.mockResolvedValueOnce({
            data: {
                name: "Device 1",
                type: "Type A",
                staticProperties: { prop1: "value1" },
                dynamicProperties: { prop2: "value2" },
                macId: "mac1",
            }
        });

        render(<PropertyPanel {...defaultProps} />);
        await waitFor(() => {
            expect(screen.getByText("Device 1")).toBeInTheDocument();
            expect(screen.getByText("Type A")).toBeInTheDocument();
            expect(screen.getByTestId("accordion")).toBeInTheDocument();
            expect(screen.getByTestId("tablist")).toBeInTheDocument();
            expect(screen.getByTestId("static-tab")).toBeInTheDocument();
        });

    });

    it("switches to Health tab and renders HealthTabContent", async () => {
        mockGetPropertyPanelData.mockResolvedValueOnce({
            data: {
                name: "Device 1",
                type: "Type A",
                staticProperties: { prop1: "value1" },
                dynamicProperties: { prop2: "value2" },
                macId: "mac1",
            }
        });

        render(<PropertyPanel {...defaultProps} />);
        await waitFor(() => {
            expect(screen.getByText("Device 1")).toBeInTheDocument();
            fireEvent.click(screen.getByText("Health"));
            expect(defaultProps.setActiveTab).toHaveBeenCalledWith("Health");
        });
    });

    it("calls setCurrentDeviceId and setCurrentDeviceFileName when device is selected", () => {
        render(<PropertyPanel {...defaultProps} currentDeviceId={null} currentDeviceFileName={null} />);
        fireEvent.change(screen.getByTestId("combobox"), { target: { value: "mac1" } });
        expect(defaultProps.setCurrentDeviceId).toHaveBeenCalledWith("mac1");
    });

    it("cleans up highlight timeout on unmount", () => {
        const { unmount } = render(<PropertyPanel {...defaultProps} />);
        unmount();
        // No error means cleanup ran
    });
});
```

## __tests__/components/PropertyPanel/PropertyPanelContent.test.tsx

```text
import React from "react";
import { render, screen, fireEvent, waitFor, act } from "@testing-library/react";
import { HealthTabContent, StaticTabContent } from "@/components/customcomponents/Propertypanel/PropertyPanelContent";
import '@testing-library/jest-dom';

// Mock dependencies
jest.mock("@/styles/scss/PropertyPanel.module.scss", () => ({
    propertyPanelTabContent: "propertyPanelTabContent",
    keyValueSection: "keyValueSection",
    alarmCard: "alarmCard",
    message: "message",
    time: "time",
    viewBtn: "viewBtn",
}));
jest.mock("@/components/customcomponents/Badge", () => (props: any) => <div data-testid="badge">{props.label}</div>);
jest.mock("@/services/alarmservice", () => ({
    getLatestAlarmForDevice: jest.fn(),
}));
jest.mock("@/utils/helperfunctions", () => ({
    formatRelativeTime: jest.fn((date) => "2 minutes ago"),
    getCollapsedAncestorsToHighlight: jest.fn(() => ["foo"]),
}));
jest.mock("@/utils/customhooks/useDeviceAlertSocket", () => ({
    useDeviceAlertSocket: jest.fn(),
}));
jest.mock("@/components/customcomponents/Propertypanel/AccordionVisibilityContext", () => ({
    useAccordionState: jest.fn(() => ({ state: {} })),
}));
jest.mock("@/utils/propertypanelfunctions", () => ({
    renderKeyValueSection: jest.fn((key, value) => (
        <span data-testid="kv">{`${key}:${value}`}</span>
    )),
    renderObject: jest.fn((key, value) => (
        <div key={key} data-testid="object">{`${key}:${JSON.stringify(value)}`}</div>
    )),
}));

describe("StaticTabContent", () => {
    it("renders key-value pairs for primitive values", () => {
        render(<StaticTabContent staticProps={{ foo: "bar", num: 42 }} />);
        expect(screen.getByText("foo:bar")).toBeInTheDocument();
        expect(screen.getByText("num:42")).toBeInTheDocument();
    });

    it("renders objects using renderObject", () => {
        render(<StaticTabContent staticProps={{ obj: { a: 1 } }} />);
        expect(screen.getByTestId("object")).toHaveTextContent("obj:{\"a\":1}");
    });
});

describe("HealthTabContent", () => {
    const mockSetIsAlarmPanelOpen = jest.fn();
    const mockSetSelectedDevicePropertyPanel = jest.fn();
    const deviceMacId = "mac123";
    const deviceName = "Device1";
    const dynamicProps = { temp: 25, nested: { humidity: 60 } };
    const highlightedPaths = ["nested"];

    beforeEach(() => {
        jest.clearAllMocks();
        (require("@/services/alarmservice").getLatestAlarmForDevice as jest.Mock).mockResolvedValue({
            data: { alarm: { message: "Overheat", raisedAt: "2024-01-01T00:00:00Z" }, totalAlarms: 3 },
        });
    });

    it("renders alarm card when alarm exists", async () => {
        render(
            <HealthTabContent
                highlightedPaths={highlightedPaths}
                deviceName={deviceName}
                setIsAlarmPanelOpen={mockSetIsAlarmPanelOpen}
                setSelectedDevicePropertyPanel={mockSetSelectedDevicePropertyPanel}
                deviceMacId={deviceMacId}
                dynamicProps={dynamicProps}
            />
        );
        await waitFor(() => {
            expect(screen.getByText("Overheat")).toBeInTheDocument();
            expect(screen.getByText("2 minutes ago")).toBeInTheDocument();
            expect(screen.getByTestId("badge")).toHaveTextContent("3");
        });
    });

    it("sets alarm and totalAlarmsForDevice to null/0 when getLatestAlarmForDevice returns no data", async () => {
        // Mock the service to return no data
        (require("@/services/alarmservice").getLatestAlarmForDevice as jest.Mock).mockResolvedValue({});

        render(
            <HealthTabContent
                highlightedPaths={highlightedPaths}
                deviceName={deviceName}
                setIsAlarmPanelOpen={mockSetIsAlarmPanelOpen}
                setSelectedDevicePropertyPanel={mockSetSelectedDevicePropertyPanel}
                deviceMacId={deviceMacId}
                dynamicProps={dynamicProps}
            />
        );

        // Wait for the DOM to update
        await waitFor(() => {
            // Alarm card should not be rendered
            expect(screen.queryByText("Overheat")).not.toBeInTheDocument();
            // Badge should not be rendered
            expect(screen.queryByTestId("badge")).not.toBeInTheDocument();
        });
    });

    it("calls setIsAlarmPanelOpen and setSelectedDevicePropertyPanel on button click", async () => {
        render(
            <HealthTabContent
                highlightedPaths={highlightedPaths}
                deviceName={deviceName}
                setIsAlarmPanelOpen={mockSetIsAlarmPanelOpen}
                setSelectedDevicePropertyPanel={mockSetSelectedDevicePropertyPanel}
                deviceMacId={deviceMacId}
                dynamicProps={dynamicProps}
            />
        );
        await waitFor(() => screen.getByText("View related alarms"));
        fireEvent.click(screen.getByText("View related alarms"));
        expect(mockSetIsAlarmPanelOpen).toHaveBeenCalledWith(true);
        expect(mockSetSelectedDevicePropertyPanel).toHaveBeenCalledWith({ deviceMacId, deviceName });
    });

    it("calls getCollapsedAncestorsToHighlight with {} when accordionContext.state is undefined", async () => {
        jest.mock("@/components/customcomponents/Propertypanel/AccordionVisibilityContext", () => ({
            useAccordionState: jest.fn(() => ({})), // state is undefined
        }));
        // Override the mock for this test only
        const mockGetCollapsedAncestorsToHighlight = require("@/utils/helperfunctions").getCollapsedAncestorsToHighlight;
        const mockUseAccordionState = require("@/components/customcomponents/Propertypanel/AccordionVisibilityContext").useAccordionState;
        mockUseAccordionState.mockImplementation(() => ({})); // state is undefined

        render(
            <HealthTabContent
                highlightedPaths={["foo"]}
                deviceName="Device1"
                setIsAlarmPanelOpen={jest.fn()}
                setSelectedDevicePropertyPanel={jest.fn()}
                deviceMacId="mac123"
                dynamicProps={{}}
            />
        );

        // Wait for useEffect/useMemo to run
        await waitFor(() => {
            expect(mockGetCollapsedAncestorsToHighlight).toHaveBeenCalledWith(["foo"], {});
        });
    });

    it("renders dynamicProps using renderObject and renderKeyValueSection", async () => {
        render(
            <HealthTabContent
                highlightedPaths={highlightedPaths}
                deviceName={deviceName}
                setIsAlarmPanelOpen={mockSetIsAlarmPanelOpen}
                setSelectedDevicePropertyPanel={mockSetSelectedDevicePropertyPanel}
                deviceMacId={deviceMacId}
                dynamicProps={dynamicProps}
            />
        );
        await waitFor(() => {
            expect(screen.getByText("temp:25")).toBeInTheDocument();
            expect(screen.getByTestId("object")).toHaveTextContent("nested:{\"humidity\":60}");
        });
    });

    //handle update function 
    it("handleAlertUpdates sets alarm and totalAlarmsForDevice when incomingUpdates is valid", async () => {
        // Mock useDeviceAlertSocket to call the handler with a valid message
        const mockUseDeviceAlertSocket = require("@/utils/customhooks/useDeviceAlertSocket").useDeviceAlertSocket;
        let handler: any;
        mockUseDeviceAlertSocket.mockImplementation((_: any, h: any) => { handler = h; });

        const { container } = render(
            <HealthTabContent
                highlightedPaths={["foo"]}
                deviceName="Device1"
                setIsAlarmPanelOpen={jest.fn()}
                setSelectedDevicePropertyPanel={jest.fn()}
                deviceMacId="mac123"
                dynamicProps={{}}
            />
        );

        // Wait for the initial alarm to render
        await waitFor(() => {
            expect(screen.getByText("Overheat")).toBeInTheDocument();
            expect(screen.getByTestId("badge")).toHaveTextContent("3");
        });

        // Simulate receiving a valid message
        act(() => {
            handler(JSON.stringify({ alarm: { message: "Test Alarm", raisedAt: "2024-01-01T00:00:00Z" }, totalAlarms: 7 }));
        });

        // Wait for the new alarm to render
        await waitFor(() => {
            expect(screen.getByText("Test Alarm")).toBeInTheDocument();
            expect(screen.getByTestId("badge")).toHaveTextContent("7");
        });
    });

    it("handleAlertUpdates sets alarm and totalAlarmsForDevice to null/0 when incomingUpdates is falsy", async () => {
        // Mock useDeviceAlertSocket to call the handler with a falsy message
        const mockUseDeviceAlertSocket = require("@/utils/customhooks/useDeviceAlertSocket").useDeviceAlertSocket;
        let handler: any;
        mockUseDeviceAlertSocket.mockImplementation((_: any, h: any) => { handler = h; });

        render(
            <HealthTabContent
                highlightedPaths={["foo"]}
                deviceName="Device1"
                setIsAlarmPanelOpen={jest.fn()}
                setSelectedDevicePropertyPanel={jest.fn()}
                deviceMacId="mac123"
                dynamicProps={{}}
            />
        );

        // Simulate receiving a falsy message
        act(() => {
            handler("null");
        });

        // Wait for the DOM to update after the state change
        await waitFor(() => {
            expect(screen.queryByText("Test Alarm")).not.toBeInTheDocument();
            expect(screen.queryByTestId("badge")).not.toBeInTheDocument();
        });
    });

    it("handleAlertUpdates clears alarm when message is empty string", async () => {
        const mockUseDeviceAlertSocket = require("@/utils/customhooks/useDeviceAlertSocket").useDeviceAlertSocket;
        let handler: any;
        mockUseDeviceAlertSocket.mockImplementation((_: any, h: any) => { handler = h; });

        render(
            <HealthTabContent
                highlightedPaths={["foo"]}
                deviceName="Device1"
                setIsAlarmPanelOpen={jest.fn()}
                setSelectedDevicePropertyPanel={jest.fn()}
                deviceMacId="mac123"
                dynamicProps={{}}
            />
        );

        // initial state from mocked getLatestAlarmForDevice
        await waitFor(() => {
            expect(screen.getByText("Overheat")).toBeInTheDocument();
            expect(screen.getByTestId("badge")).toHaveTextContent("3");
        });

        // send empty string â€” should clear alarm/state and not throw
        act(() => {
            handler("");
        });

        await waitFor(() => {
            expect(screen.queryByText("Overheat")).not.toBeInTheDocument();
            expect(screen.queryByTestId("badge")).not.toBeInTheDocument();
        });
    });

    // Access the memo compare function
    const memoCompare = (HealthTabContent as any).type?.compare || (HealthTabContent as any).compare;

    describe("HealthTabContent memo compare", () => {
        it("returns true when deviceMacId and highlightedPaths are equal", () => {
            const prevProps = { deviceMacId: "mac1", highlightedPaths: ["a", "b"] };
            const nextProps = { deviceMacId: "mac1", highlightedPaths: ["a", "b"] };
            expect(memoCompare(prevProps, nextProps)).toBe(true);
        });

        it("returns false when deviceMacId is different", () => {
            const prevProps = { deviceMacId: "mac1", highlightedPaths: ["a", "b"] };
            const nextProps = { deviceMacId: "mac2", highlightedPaths: ["a", "b"] };
            expect(memoCompare(prevProps, nextProps)).toBe(false);
        });

        it("returns false when highlightedPaths is different", () => {
            const prevProps = { deviceMacId: "mac1", highlightedPaths: ["a", "b"] };
            const nextProps = { deviceMacId: "mac1", highlightedPaths: ["a", "c"] };
            expect(memoCompare(prevProps, nextProps)).toBe(false);
        });
    });
});
```

## __tests__/components/PropertyPanel/TabList.test.tsx

```text
import React from "react";
import { render, fireEvent } from "@testing-library/react";
import TabList from "@/components/customcomponents/Propertypanel/TabList";
import '@testing-library/jest-dom';

// Mock styles
jest.mock("@/styles/scss/PropertyPanel.module.scss", () => ({
    tabListUL: "tabListUL",
    tabListLi: "tabListLi",
    tabListLiActive: "tabListLiActive",
    highlightedTitle: "highlightedTitle",
}));

// Mock AccordionVisibilityContext
const toggleMock = jest.fn();
const getStateMock = jest.fn();
const useAccordionStateMock = jest.fn();

jest.mock(
    "@/components/customcomponents/Propertypanel/AccordionVisibilityContext",
    () => ({
        useAccordionState: () => useAccordionStateMock(),
    })
);

describe("TabList", () => {
    const setActiveTab = jest.fn();

    beforeEach(() => {
        jest.clearAllMocks();
    });

    it("renders both tabs", () => {
        useAccordionStateMock.mockReturnValue({});
        const { getByText } = render(
            <TabList highlightedPaths={[]} activeTab="Static" setActiveTab={setActiveTab} />
        );
        expect(getByText("Static")).toBeInTheDocument();
        expect(getByText("Health")).toBeInTheDocument();
    });

    it("calls setActiveTab and toggle when a tab is clicked", () => {
        useAccordionStateMock.mockReturnValue({
            state: true,
            toggle: toggleMock,
            getState: getStateMock,
        });
        const { getByText } = render(
            <TabList highlightedPaths={[]} activeTab="Static" setActiveTab={setActiveTab} />
        );
        fireEvent.click(getByText("Health"));
        expect(setActiveTab).toHaveBeenCalledWith("Health");
        expect(toggleMock).toHaveBeenCalledWith("Health", true);
    });

    it("applies active class to the active tab", () => {
        useAccordionStateMock.mockReturnValue({});
        const { getByText } = render(
            <TabList highlightedPaths={[]} activeTab="Health" setActiveTab={setActiveTab} />
        );
        const healthTab = getByText("Health");
        expect(healthTab.className).toContain("tabListLiActive");
    });

    it("applies highlightedTitle class when conditions are met", () => {
        getStateMock.mockReturnValue(false);
        useAccordionStateMock.mockReturnValue({
            getState: getStateMock,
        });
        const { getByText } = render(
            <TabList highlightedPaths={["/some/path"]} activeTab="Health" setActiveTab={setActiveTab} />
        );
        const healthTab = getByText("Health");
        expect(healthTab.className).toContain("highlightedTitle");
    });

    it("does not apply highlightedTitle class when conditions are not met", () => {
        getStateMock.mockReturnValue(true);
        useAccordionStateMock.mockReturnValue({
            getState: getStateMock,
        });
        const { getByText } = render(
            <TabList highlightedPaths={[]} activeTab="Health" setActiveTab={setActiveTab} />
        );
        const healthTab = getByText("Health");
        expect(healthTab.className).not.toContain("highlightedTitle");
    });
});
```

## __tests__/components/Sidebar.test.tsx

```text
import '@testing-library/jest-dom';
import React from "react";
import { render, screen, fireEvent } from "@testing-library/react";
import Sidebar from "@/components/customcomponents/SideBar";
import { Provider } from '@/components/ui/provider';

// Mock window.matchMedia for tests
beforeAll(() => {
    Object.defineProperty(window, 'matchMedia', {
        writable: true,
        value: jest.fn().mockImplementation(query => ({
            matches: false,
            media: query,
            onchange: null,
            addListener: jest.fn(), // deprecated
            removeListener: jest.fn(), // deprecated
            addEventListener: jest.fn(),
            removeEventListener: jest.fn(),
            dispatchEvent: jest.fn(),
        })),
    });
});

describe("Sidebar", () => {
    const closeIconMsg = "Close sidebar";
    const openIconMsg = "Open sidebar";
    const children = <div data-testid="sidebar-content">Sidebar Content</div>;

    const renderWithProvider = (ui: React.ReactElement) =>
        render(<Provider>{ui}</Provider>);

    it("renders children", () => {
        renderWithProvider(
            <Sidebar isOpen={true} closeIconMsg={closeIconMsg} openIconMsg={openIconMsg}>
                {children}
            </Sidebar>
        );
        expect(screen.getByTestId("sidebar-content")).toBeInTheDocument();
    });

    //left sidebar tests
    it("shows close button when open (left)", () => {
        renderWithProvider(
            <Sidebar position="left" isOpen={true} closeIconMsg={closeIconMsg} openIconMsg={openIconMsg} />
        );
        expect(screen.getByTestId("Leftsidebar-close-button")).toBeInTheDocument();
    });

    it("shows open icon when closed (left)", () => {
        renderWithProvider(
            <Sidebar position="left" isOpen={false} closeIconMsg={closeIconMsg} openIconMsg={openIconMsg} />
        );
        expect(screen.getByTestId("Leftsidebar-open-button")).toBeInTheDocument();
    });

    it("calls setIsOpen(false) when close button clicked (left)", () => {
        const setIsOpen = jest.fn();
        renderWithProvider(
            <Sidebar position="left" isOpen={true} setIsOpen={setIsOpen} closeIconMsg={closeIconMsg} openIconMsg={openIconMsg} />
        );
        fireEvent.click(screen.getByTestId("Leftsidebar-close-button"));
        expect(setIsOpen).toHaveBeenCalledWith(false);
    });

    it("calls setIsOpen(true) when open icon clicked (left)", () => {
        const setIsOpen = jest.fn();
        renderWithProvider(
            <Sidebar position="left" isOpen={false} setIsOpen={setIsOpen} closeIconMsg={closeIconMsg} openIconMsg={openIconMsg} />
        );
        fireEvent.click(screen.getByTestId("Leftsidebar-open-button"));
        expect(setIsOpen).toHaveBeenCalledWith(true);
    });

    //right sidebar tests
    it("shows close button when open (right)", () => {
        renderWithProvider(
            <Sidebar position="right" isOpen={true} closeIconMsg={closeIconMsg} openIconMsg={openIconMsg} />
        );
        expect(screen.getByTestId("Rightsidebar-close-button")).toBeInTheDocument();
    });

    it("shows open icon when closed (right)", () => {
        renderWithProvider(
            <Sidebar position="right" isOpen={false} closeIconMsg={closeIconMsg} openIconMsg={openIconMsg} />
        );
        expect(screen.getByTestId("Rightsidebar-open-button")).toBeInTheDocument();
    });

    it("calls closeSidebar() when close button clicked (right)", () => {
        const closeSidebar = jest.fn();
        renderWithProvider(
            <Sidebar position="right" isOpen={true} closeSidebar={closeSidebar} closeIconMsg={closeIconMsg} openIconMsg={openIconMsg} />
        );
        fireEvent.click(screen.getByTestId("Rightsidebar-close-button"));
        expect(closeSidebar).toHaveBeenCalled();
    });

    it("calls setIsOpen(true) when open icon clicked (right)", () => {
        const setIsOpen = jest.fn();
        renderWithProvider(
            <Sidebar position="right" isOpen={false} setIsOpen={setIsOpen} closeIconMsg={closeIconMsg} openIconMsg={openIconMsg} />
        );
        fireEvent.click(screen.getByTestId("Rightsidebar-open-button"));
        expect(setIsOpen).toHaveBeenCalledWith(true);
    });
    
});
```

## __tests__/components/Table/TableComponent.test.tsx

```text
import React from "react";
import { render, screen, fireEvent } from "@testing-library/react";
import TableComponent from "@/components/customcomponents/Table/TableComponent";
import '@testing-library/jest-dom';
import { flexRender } from "@tanstack/react-table";


// Mock dependencies
jest.mock("@/components/customcomponents/Table/TableRow", () => (props: any) => (
    <tr data-testid="tablerow-mock">
        {props.row.getVisibleCells().map((cell: any) => (
            <td key={cell.id}>{flexRender(cell.column.columnDef.cell, cell.getContext())}</td>
        ))}
    </tr>
));
jest.mock("@/components/customcomponents/Pagination", () => (props: any) => (
    <div data-testid="pagination-mock">
        <button onClick={() => props.setCurrentPage(1)}>Page 1</button>
    </div>
));
jest.mock("@/utils/helperfunctions", () => ({
    capitalizeFirstLetter: (str: string) => str.charAt(0).toUpperCase() + str.slice(1),
    formatDateTime: (val: string) => `formatted-${val}`,
}));

jest.mock("lucide-react", () => ({
    ArrowUp: () => <span data-testid="arrow-up" />,
    ArrowDown: () => <span data-testid="arrow-down" />,
}));

describe("TableComponent", () => {
    const baseProps = {
        currentDeviceId: "device1",
        sorting: [],
        setSorting: jest.fn(),
        refreshDeviceDataKey: 1,
        updatedFieldsMap: {},
        currentPage: 1,
        setCurrentPage: jest.fn(),
        totalPages: 2,
        pageSize: 5,
        setPageSize: jest.fn(),
        setIsPropertyPanelOpen: jest.fn(),
    };

    it("renders 'No data available.' when data is empty", () => {
        render(<TableComponent {...baseProps} data={[]} />);
        expect(screen.getByText("No data available.")).toBeInTheDocument();
    });

    it("renders table headers and rows", () => {
        const data = [
            { id: 1, name: "Device A", lastUpdated: "2024-06-01T12:00:00Z" },
            { id: 2, name: "Device B", lastUpdated: "2024-06-02T12:00:00Z" },
        ];
        render(<TableComponent {...baseProps} data={data} />);
        expect(screen.getByText("Id")).toBeInTheDocument();
        expect(screen.getByText("Name")).toBeInTheDocument();
        expect(screen.getByText("LastUpdated")).toBeInTheDocument();
        // TableRow mock renders cell values
        expect(screen.getAllByTestId("tablerow-mock")).toHaveLength(2);
        expect(screen.getByText("Device A")).toBeInTheDocument();
        expect(screen.getByText("Device B")).toBeInTheDocument();
        expect(screen.getByText("formatted-2024-06-01T12:00:00Z")).toBeInTheDocument();
    });

    it("renders Pagination component", () => {
        const data = [{ id: 1, name: "Device A", lastUpdated: "2024-06-01T12:00:00Z" }];
        render(<TableComponent {...baseProps} data={data} />);
        expect(screen.getByTestId("pagination-mock")).toBeInTheDocument();
    });

    it("calls setSorting when header is clicked", () => {
        const data = [
            { id: 1, name: "Device A", lastUpdated: "2024-06-01T12:00:00Z" },
            { id: 2, name: "Device B", lastUpdated: "2024-06-02T12:00:00Z" },
        ];
        const setSorting = jest.fn();
        render(<TableComponent {...baseProps} data={data} setSorting={setSorting} />);
        // Find the first header cell (Id)
        const header = screen.getByText("Id");
        fireEvent.click(header);
        // setSorting should be called (handled by react-table, so we check if it was called at least once)
        expect(setSorting).toHaveBeenCalled();
    });

    it("shows ArrowUp icon when column is sorted ascending", () => {
        const data = [
            { id: 1, name: "Device A", lastUpdated: "2024-06-01T12:00:00Z" },
            { id: 2, name: "Device B", lastUpdated: "2024-06-02T12:00:00Z" },
        ];
        // Simulate sorting state for 'id' column ascending
        render(
            <TableComponent
                {...baseProps}
                data={data}
                sorting={[{ id: "id", desc: false }]}
            />
        );
        // ArrowUp should be in the document
        expect(screen.getByTestId("arrow-up")).toBeInTheDocument();
        // Optionally, check for ArrowUp by title or role if your icon lib supports it
    });

    it("shows ArrowDown icon when column is sorted descending", () => {
        const data = [
            { id: 1, name: "Device A", lastUpdated: "2024-06-01T12:00:00Z" },
            { id: 2, name: "Device B", lastUpdated: "2024-06-02T12:00:00Z" },
        ];
        // Simulate sorting state for 'id' column descending
        render(
            <TableComponent
                {...baseProps}
                data={data}
                sorting={[{ id: "id", desc: true }]}
            />
        );
        // ArrowDown should be in the document
        expect(screen.getByTestId("arrow-down")).toBeInTheDocument();
    });

    it("shows no sort icon when column is not sorted", () => {
        const data = [
            { id: 1, name: "Device A", lastUpdated: "2024-06-01T12:00:00Z" },
            { id: 2, name: "Device B", lastUpdated: "2024-06-02T12:00:00Z" },
        ];
        // No sorting applied
        render(
            <TableComponent
                {...baseProps}
                data={data}
                sorting={[]}
            />
        );
        // No ArrowUp or ArrowDown icon should be present
        expect(screen.queryByTestId("arrow-up")).not.toBeInTheDocument();
        expect(screen.queryByTestId("arrow-down")).not.toBeInTheDocument();
    });

    it("calls sorting handler when sortable header is clicked", () => {
        const data = [{ id: 1, name: "Device A" }];
        const setSorting = jest.fn();
        render(<TableComponent {...baseProps} data={data} setSorting={setSorting} />);
        // Find the sortable header (Id)
        const header = screen.getByText("Id");
        fireEvent.click(header);
        expect(setSorting).toHaveBeenCalled();
    });
});
```

## __tests__/components/Table/TableRow.test.tsx

```text
import React from "react";
import { render, fireEvent, act, waitFor } from "@testing-library/react";
import TableRow from "@/components/customcomponents/Table/TableRow";
import '@testing-library/jest-dom';
import { areEqual } from "@/components/customcomponents/Table/TableRow";

// Mock styles import
jest.mock("@/styles/scss/Table.module.scss", () => ({
    row: "row",
    rowSelected: "rowSelected",
    cell: "cell",
    highlightedCell: "highlightedCell",
}));

// Mock flexRender
jest.mock("@tanstack/react-table", () => ({
    flexRender: jest.fn((renderer, ctx) => {
        if (typeof renderer === "function") return renderer(ctx);
        return renderer;
    }),
    Row: jest.fn(),
}));

const getMockRow = (overrides: any = {}) => ({
    original: {
        macId: "mac-123",
        status: "online",
        connectivity: "wifi",
        id: "row-1",
        ...overrides.original,
    },
    getVisibleCells: () => [
        {
            id: "cell-1",
            column: { id: "status", columnDef: { cell: (ctx: any) => ctx.row.original.status } },
            getContext: () => ({ row: { original: { macId: "mac-123", status: "online" } } }),
        },
        {
            id: "cell-2",
            column: { id: "connectivity", columnDef: { cell: (ctx: any) => ctx.row.original.connectivity } },
            getContext: () => ({ row: { original: { macId: "mac-123", connectivity: "wifi" } } }),
        },
    ],
});

describe("TableRow", () => {
    jest.useFakeTimers();

    const setIsPropertyPanelOpen = jest.fn();

    it("renders row and cells correctly", () => {
        const row = getMockRow();
        const { getByText } = render(
            <table>
                <tbody>
                    <TableRow
                        row={row as any} // row is of type Row<any>
                        setIsPropertyPanelOpen={setIsPropertyPanelOpen}
                        updatedFieldsMap={null}
                        refreshDeviceDataKey={1}
                        currentDeviceId={null}
                    />
                </tbody>
            </table>
        );
        expect(getByText("online")).toBeInTheDocument();
        expect(getByText("wifi")).toBeInTheDocument();
    });

    it("applies rowSelected class when currentDeviceId matches macId", () => {
        const row = getMockRow();
        const { container } = render(
            <table>
                <tbody>
                    <TableRow
                        row={row as any}
                        setIsPropertyPanelOpen={setIsPropertyPanelOpen}
                        updatedFieldsMap={null}
                        refreshDeviceDataKey={1}
                        currentDeviceId="mac-123"
                    />
                </tbody>
            </table>
        );
        expect(container.querySelector("tr")?.className).toContain("rowSelected");
    });

    it("calls setIsPropertyPanelOpen with macId on row click", () => {
        const row = getMockRow();
        const { container } = render(
            <table>
                <tbody>
                    <TableRow
                        row={row as any}
                        setIsPropertyPanelOpen={setIsPropertyPanelOpen}
                        updatedFieldsMap={null}
                        refreshDeviceDataKey={1}
                        currentDeviceId={null}
                    />
                </tbody>
            </table>
        );
        fireEvent.click(container.querySelector("tr")!);
        expect(setIsPropertyPanelOpen).toHaveBeenCalledWith("mac-123");
    });

    it("highlights updated fields and removes highlight after 3 seconds", async () => {
        const row = getMockRow();
        const updatedFieldsMap = { "mac-123": ["status"] };
        const { container } = render(
            <table>
                <tbody>
                    <TableRow
                        row={row as any}
                        setIsPropertyPanelOpen={setIsPropertyPanelOpen}
                        updatedFieldsMap={updatedFieldsMap}
                        currentDeviceId={null}
                    />
                </tbody>
            </table>
        );

        // Advance timers by 0 to flush any immediate timer-based updates
        act(() => {
            jest.advanceTimersByTime(1000);
        });

        // Wait for DOM update so <td> elements are guaranteed rendered
        await waitFor(() => {
            const tds = container.querySelectorAll("td");
            expect(tds.length).toBeGreaterThan(0);
        });

        let tds = container.querySelectorAll("td");

        expect(tds[0].classList.contains("highlightedCell")).toBe(true);
        expect(tds[1].classList.contains("highlightedCell")).toBe(false);

        // Advance timers by 3 seconds to remove highlight
        act(() => {
            jest.advanceTimersByTime(3000);
        });

        // Query again and check class removal
        await waitFor(() => {
            tds = container.querySelectorAll("td");
        });
        expect(tds[0].classList.contains("highlightedCell")).toBe(false);
    });

    it("removes highlight when refreshDeviceDataKey changes", () => {
        const row = getMockRow();
        const updatedFieldsMap = { "mac-123": ["status"] };
        const { rerender, container } = render(
            <table>
                <tbody>
                    <TableRow
                        row={row as any}
                        setIsPropertyPanelOpen={setIsPropertyPanelOpen}
                        updatedFieldsMap={updatedFieldsMap}
                        currentDeviceId={null}
                    />
                </tbody>
            </table>
        );
        // status cell should be highlighted
        expect(container.querySelectorAll("td")[0].classList.contains("highlightedCell")).toBe(true);

        // Change refreshDeviceDataKey
        rerender(
            <table>
                <tbody>
                    <TableRow
                        row={row as any}
                        setIsPropertyPanelOpen={setIsPropertyPanelOpen}
                        updatedFieldsMap={updatedFieldsMap}
                        refreshDeviceDataKey={2}
                        currentDeviceId={null}
                    />
                </tbody>
            </table>
        );
        expect(container.querySelectorAll("td")[0].classList.contains("highlightedCell")).toBe(false);
    });

    // areEqual function tests
    describe("areEqual", () => {
        const getProps = (overrides: any = {}): any => ({
            row: { original: { macId: "mac-123", status: "online", connectivity: "wifi", ...(overrides.row?.original || {}) } },
            setIsPropertyPanelOpen,
            updatedFieldsMap: overrides.updatedFieldsMap ?? { "mac-123": ["status"] },
            refreshDeviceDataKey: overrides.refreshDeviceDataKey ?? 1,
            currentDeviceId: overrides.currentDeviceId ?? "mac-123",
        });

        it("returns false if refreshDeviceDataKey changes", () => {
            const prevProps = getProps({ refreshDeviceDataKey: 1 });
            const nextProps = getProps({ refreshDeviceDataKey: 2 });
            expect(areEqual(prevProps, nextProps)).toBe(false);
        });

        it("returns false if currentDeviceId changes", () => {
            const prevProps = getProps({ currentDeviceId: "mac-123" });
            const nextProps = getProps({ currentDeviceId: "mac-456" });
            expect(areEqual(prevProps, nextProps)).toBe(false);
        });

        it("returns false if macId changes", () => {
            const prevProps = getProps({ row: { original: { macId: "mac-123", status: "online", connectivity: "wifi" } } });
            const nextProps = getProps({ row: { original: { macId: "mac-456", status: "online", connectivity: "wifi" } } });
            expect(areEqual(prevProps, nextProps)).toBe(false);
        });

        it("returns false if status changes", () => {
            const prevProps = getProps({ row: { original: { macId: "mac-123", status: "online", connectivity: "wifi" } } });
            const nextProps = getProps({ row: { original: { macId: "mac-123", status: "offline", connectivity: "wifi" } } });
            expect(areEqual(prevProps, nextProps)).toBe(false);
        });

        it("returns false if connectivity changes", () => {
            const prevProps = getProps({ row: { original: { macId: "mac-123", status: "online", connectivity: "wifi" } } });
            const nextProps = getProps({ row: { original: { macId: "mac-123", status: "online", connectivity: "ethernet" } } });
            expect(areEqual(prevProps, nextProps)).toBe(false);
        });

        it("returns false if updatedFieldsMap contents change (length)", () => {
            const prevProps = getProps({ updatedFieldsMap: { "mac-123": ["status"] } });
            const nextProps = getProps({ updatedFieldsMap: { "mac-123": ["status", "macId"] } });
            expect(areEqual(prevProps, nextProps)).toBe(false);
        });

        it("returns false if updatedFieldsMap contents change (value)", () => {
            const prevProps = getProps({ updatedFieldsMap: { "mac-123": ["status"] } });
            const nextProps = getProps({ updatedFieldsMap: { "mac-123": [] } });
            expect(areEqual(prevProps, nextProps)).toBe(false);
        });

        it("returns true if nothing relevant changes", () => {
            const prevProps = getProps();
            const nextProps = getProps();
            expect(areEqual(prevProps, nextProps)).toBe(true);
        });
    });

});
```

## __tests__/hooks/useDeviceTopDataSocket.test.ts

```typescript
import { renderHook, act } from "@testing-library/react";
import { getSignalRConnection } from "@/sockets/signalRConnection";
import { useDevicesTopDataSocket } from "@/utils/customhooks/useDevicesTopDataSocket";

// Mock getSignalRConnection import
jest.mock("@/sockets/signalRConnection", () => ({
  getSignalRConnection: jest.fn(),
}));

// Create a fake SignalR connection mock
const mockOn = jest.fn();
const mockOff = jest.fn();

const mockConnection = {
  on: mockOn,
  off: mockOff,
};

describe("useDevicesTopDataSocket", () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  test("sets up SignalR connection and subscribes to ReceiveUpdate", async () => {
    // Mock getSignalRConnection to return a fake connection
    (getSignalRConnection as jest.Mock).mockResolvedValue(mockConnection);

    const onUpdate = jest.fn();

    await act(async () => {
      renderHook(() => useDevicesTopDataSocket(onUpdate));
    });

    expect(getSignalRConnection).toHaveBeenCalledTimes(1);
    expect(mockOn).toHaveBeenCalledWith("ReceiveUpdate", expect.any(Function));
  });

  test("calls onUpdate when ReceiveUpdate handler is triggered", async () => {
    let handler: any;
    (getSignalRConnection as jest.Mock).mockResolvedValue({
      on: (event: string, fn: any) => {
        if (event === "ReceiveUpdate") handler = fn;
      },
      off: jest.fn(),
    });

    const onUpdate = jest.fn();
    await act(async () => {
      renderHook(() => useDevicesTopDataSocket(onUpdate));
    });

    const mockData = { id: 1, name: "Device A" };
    handler(mockData);

    expect(onUpdate).toHaveBeenCalledWith(mockData);
  });

  test("cleans up the event listener on unmount", async () => {
    (getSignalRConnection as jest.Mock).mockResolvedValue(mockConnection);

    const { unmount } = renderHook(() =>
      useDevicesTopDataSocket(jest.fn())
    );

    await act(async () => {}); // wait for effect to settle

    unmount();

    expect(mockOff).toHaveBeenCalledWith("ReceiveUpdate", expect.any(Function));
  });

  test("logs a warning when no connection is available", async () => {
    const consoleWarnSpy = jest.spyOn(console, "warn").mockImplementation(() => {});
    (getSignalRConnection as jest.Mock).mockResolvedValue(null);

    await act(async () => {
      renderHook(() => useDevicesTopDataSocket(jest.fn()));
    });

    expect(consoleWarnSpy).toHaveBeenCalledWith("SignalR connection not available");
    consoleWarnSpy.mockRestore();
  });
});
```

## __tests__/Pages/app.test.tsx

```text
import React from "react";
import { render, screen } from "@testing-library/react";
import App from "@/pages/_app";

jest.mock("rsuite", () => ({
    CustomProvider: ({ children, ...rest }: any) => (
        <div data-testid="rsuite-provider" {...rest}>
            {children}
        </div>
    ),
}));

jest.mock("@/components/ui/provider", () => ({
    Provider: ({ children }: any) => <div data-testid="app-provider">{children}</div>,
}));

// minimal mock router to satisfy Next.js _app props
const mockRouter = {
    pathname: "/",
    route: "/",
    asPath: "/",
    query: {},
    push: jest.fn(),
    replace: jest.fn(),
    reload: jest.fn(),
    back: jest.fn(),
    prefetch: jest.fn().mockResolvedValue(undefined),
    beforePopState: jest.fn(),
    events: { on: jest.fn(), off: jest.fn(), emit: jest.fn() },
    isFallback: false,
} as any;

describe("App", () => {
    it("renders the page component and passes pageProps", () => {
        const Page = ({ text }: any) => <div>{text}</div>;
        render(<App Component={Page} pageProps={{ text: "hello world" }} router={mockRouter} />);
        expect(screen.getByText("hello world")).toBeTruthy();
    });

    it("wraps the page with CustomProvider and Provider (correct nesting)", () => {
        const Page = () => <div>inner</div>;
        render(<App Component={Page} pageProps={{}} router={mockRouter} />);
        const rsuite = screen.getByTestId("rsuite-provider");
        const appProvider = screen.getByTestId("app-provider");
        expect(rsuite).toBeTruthy();
        expect(appProvider).toBeTruthy();
        expect(rsuite.contains(appProvider)).toBe(true);
    });
});
```

## __tests__/Pages/document.test.tsx

```text
import Document from "@/pages/_document";
import React from "react";
import { renderToStaticMarkup } from "react-dom/server";

jest.mock("next/document", () => {
    return {
        Html: ({ children, ...props }: any) =>
            React.createElement("html", props, children),
        Head: ({ children }: any) => React.createElement("head", null, children),
        Main: () =>
            React.createElement("div", { "data-testid": "main" }, "MAIN_PLACEHOLDER"),
        NextScript: () =>
            React.createElement(
                "script",
                { "data-testid": "next-script" },
                "NEXT_SCRIPT"
            ),
    };
});


describe("Document", () => {
    it("renders an html element with lang=\"en\"", () => {
        const html = renderToStaticMarkup(<Document />);
        expect(html).toContain('<html lang="en"');
    });

    it("includes Head, Main and NextScript output", () => {
        const html = renderToStaticMarkup(<Document />);
        expect(html).toContain("<head");
        expect(html).toContain("MAIN_PLACEHOLDER");
        expect(html).toContain("NEXT_SCRIPT");
    });
});
```

## __tests__/signalRConnection.test.ts

```typescript
import { jest } from "@jest/globals";

jest.mock("@/utils/helpervariables", () => ({
  websocketGatewayUrl: "ws://mock-url",
}));

// Typed mocks for SignalR
let mockStart: jest.MockedFunction<() => Promise<void>>;
let mockBuild: jest.MockedFunction<() => any>;
let mockWithAutomaticReconnect: jest.MockedFunction<() => any>;
let mockWithUrl: jest.MockedFunction<() => any>;

mockStart = jest.fn();
mockWithUrl = jest.fn();
mockWithAutomaticReconnect = jest.fn();
mockBuild = jest.fn();

jest.mock("@microsoft/signalr", () => {
  mockWithUrl.mockReturnValue({ withAutomaticReconnect: mockWithAutomaticReconnect });
  mockWithAutomaticReconnect.mockReturnValue({ build: mockBuild });
  mockBuild.mockReturnValue({ start: mockStart });

  return {
    HubConnectionBuilder: jest.fn(() => ({
      withUrl: mockWithUrl,
      withAutomaticReconnect: mockWithAutomaticReconnect,
      build: mockBuild,
    })),
  };
});

const mockConsole = {
  log: jest.spyOn(console, "log").mockImplementation(() => {}),
  warn: jest.spyOn(console, "warn").mockImplementation(() => {}),
};

describe("getSignalRConnection", () => {
  beforeEach(() => {
    jest.resetModules();
    jest.clearAllMocks();
    mockStart.mockReset();
  });

  it("should create and start a new SignalR connection", async () => {
    mockStart.mockResolvedValue();

    const { getSignalRConnection } = await import("../sockets/signalRConnection");
    const conn = await getSignalRConnection();

    expect(conn.start).toBe(mockStart);
    expect(mockConsole.log).toHaveBeenCalledWith("SignalR connected to GatewayHub.");
  });

  it("should return cached connection if called twice", async () => {
    mockStart.mockResolvedValue();

    const { getSignalRConnection } = await import("../sockets/signalRConnection");
    const first = await getSignalRConnection();
    const second = await getSignalRConnection();

    expect(first).toBe(second);
  });

  it("should log warning if start() fails", async () => {
    const error = new Error("failed");
    mockStart.mockRejectedValue(error);

    const { getSignalRConnection } = await import("../sockets/signalRConnection");
    await getSignalRConnection();

    expect(mockConsole.warn).toHaveBeenCalledWith("SignalR connection failed:", error);
  });
});
```

## Statistics

- Total Files: 73
- Total Characters: 246005
- Total Tokens: 0
